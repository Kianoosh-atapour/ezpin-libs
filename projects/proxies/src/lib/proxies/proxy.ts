//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from "rxjs/operators";
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
} from "rxjs";
import { Injectable, Inject, Optional, InjectionToken } from "@angular/core";
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
  HttpContext,
} from "@angular/common/http";
import { ProxiesService } from "proxies";

const service = new ProxiesService();
const API_BASE_URL = service.retailProxyBaseUrl;

@Injectable()
export class BanksClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(bankName: string, httpContext?: HttpContext): Observable<Bank> {
    let url_ = this.baseUrl + "/api/v1/banks?";
    if (bankName === undefined || bankName === null)
      throw new Error(
        "The parameter 'bankName' must be defined and cannot be null."
      );
    else url_ += "bankName=" + encodeURIComponent("" + bankName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Bank>;
            }
          } else return _observableThrow(response_) as any as Observable<Bank>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<Bank> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Bank.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getBanks(
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<Bank[]> {
    let url_ = this.baseUrl + "/api/v1/banks?";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBanks(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBanks(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Bank[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Bank[]>;
        })
      );
  }

  protected processGetBanks(response: HttpResponseBase): Observable<Bank[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(Bank.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(bankId: number, httpContext?: HttpContext): Observable<Bank> {
    let url_ = this.baseUrl + "/api/v1/banks/{bankId}";
    if (bankId === undefined || bankId === null)
      throw new Error("The parameter 'bankId' must be defined.");
    url_ = url_.replace("{bankId}", encodeURIComponent("" + bankId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Bank>;
            }
          } else return _observableThrow(response_) as any as Observable<Bank>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<Bank> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Bank.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    bankId: number,
    bankName: string,
    httpContext?: HttpContext
  ): Observable<Bank> {
    let url_ = this.baseUrl + "/api/v1/banks/{bankId}?";
    if (bankId === undefined || bankId === null)
      throw new Error("The parameter 'bankId' must be defined.");
    url_ = url_.replace("{bankId}", encodeURIComponent("" + bankId));
    if (bankName === undefined || bankName === null)
      throw new Error(
        "The parameter 'bankName' must be defined and cannot be null."
      );
    else url_ += "bankName=" + encodeURIComponent("" + bankName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Bank>;
            }
          } else return _observableThrow(response_) as any as Observable<Bank>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<Bank> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Bank.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class BranchesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    branchId: number,
    branchName: string,
    description?: string | null | undefined,
    httpContext?: HttpContext
  ): Observable<BranchLight> {
    let url_ = this.baseUrl + "/api/v1/branches?";
    if (branchId === undefined || branchId === null)
      throw new Error(
        "The parameter 'branchId' must be defined and cannot be null."
      );
    else url_ += "branchId=" + encodeURIComponent("" + branchId) + "&";
    if (branchName === undefined || branchName === null)
      throw new Error(
        "The parameter 'branchName' must be defined and cannot be null."
      );
    else url_ += "branchName=" + encodeURIComponent("" + branchName) + "&";
    if (description !== undefined && description !== null)
      url_ += "description=" + encodeURIComponent("" + description) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BranchLight>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<BranchLight>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<BranchLight> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BranchLight.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSubBranches(
    branchId: number,
    httpContext?: HttpContext
  ): Observable<Branch[]> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sub-branches";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSubBranches(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSubBranches(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Branch[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Branch[]>;
        })
      );
  }

  protected processGetSubBranches(
    response: HttpResponseBase
  ): Observable<Branch[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Branch.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  assignMerchant(
    branchId: number,
    merchantId: number,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/assign-merchant/{merchantId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssignMerchant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssignMerchant(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAssignMerchant(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  assignPriceList(
    branchId: number,
    priceListId: number,
    targetBranchId: number,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/assign-price-list/{priceListId}/targetBranchId/{targetBranchId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (priceListId === undefined || priceListId === null)
      throw new Error("The parameter 'priceListId' must be defined.");
    url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
    if (targetBranchId === undefined || targetBranchId === null)
      throw new Error("The parameter 'targetBranchId' must be defined.");
    url_ = url_.replace(
      "{targetBranchId}",
      encodeURIComponent("" + targetBranchId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssignPriceList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssignPriceList(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAssignPriceList(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSubMerchants(
    branchId: number,
    saleManagerId?: number | null | undefined,
    isAssignedToSaleManager?: boolean | null | undefined,
    isRecursive?: boolean | undefined,
    priceListId?: number | null | undefined,
    searchCriteria?: string | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<Branch[]> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sub-merchants?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (saleManagerId !== undefined && saleManagerId !== null)
      url_ += "saleManagerId=" + encodeURIComponent("" + saleManagerId) + "&";
    if (
      isAssignedToSaleManager !== undefined &&
      isAssignedToSaleManager !== null
    )
      url_ +=
        "isAssignedToSaleManager=" +
        encodeURIComponent("" + isAssignedToSaleManager) +
        "&";
    if (isRecursive === null)
      throw new Error("The parameter 'isRecursive' cannot be null.");
    else if (isRecursive !== undefined)
      url_ += "isRecursive=" + encodeURIComponent("" + isRecursive) + "&";
    if (priceListId !== undefined && priceListId !== null)
      url_ += "priceListId=" + encodeURIComponent("" + priceListId) + "&";
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSubMerchants(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSubMerchants(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Branch[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Branch[]>;
        })
      );
  }

  protected processGetSubMerchants(
    response: HttpResponseBase
  ): Observable<Branch[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Branch.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAllMerchantsBranch(
    searchCriteria?: string | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<Branch[]> {
    let url_ = this.baseUrl + "/api/v1/branches/all-merchants-branch?";
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllMerchantsBranch(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllMerchantsBranch(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Branch[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Branch[]>;
        })
      );
  }

  protected processGetAllMerchantsBranch(
    response: HttpResponseBase
  ): Observable<Branch[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Branch.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(
    branchId: number,
    includeSubBranches?: boolean | undefined,
    httpContext?: HttpContext
  ): Observable<Branch> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (includeSubBranches === null)
      throw new Error("The parameter 'includeSubBranches' cannot be null.");
    else if (includeSubBranches !== undefined)
      url_ +=
        "includeSubBranches=" +
        encodeURIComponent("" + includeSubBranches) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Branch>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Branch>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<Branch> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Branch.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class BuyOrdersClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getSaleOrders(
    branchId: number,
    subMerchantId?: number | null | undefined,
    currencyId?: number | null | undefined,
    isPhysicalCardOrder?: boolean | undefined,
    searchCriteria?: string | null | undefined,
    buyOrderStates?: string | null | undefined,
    beginTime?: Date | null | undefined,
    endTime?: Date | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<BuyOrder[]> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/sales?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (subMerchantId !== undefined && subMerchantId !== null)
      url_ += "subMerchantId=" + encodeURIComponent("" + subMerchantId) + "&";
    if (currencyId !== undefined && currencyId !== null)
      url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
    if (isPhysicalCardOrder === null)
      throw new Error("The parameter 'isPhysicalCardOrder' cannot be null.");
    else if (isPhysicalCardOrder !== undefined)
      url_ +=
        "isPhysicalCardOrder=" +
        encodeURIComponent("" + isPhysicalCardOrder) +
        "&";
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    if (buyOrderStates !== undefined && buyOrderStates !== null)
      url_ += "buyOrderStates=" + encodeURIComponent("" + buyOrderStates) + "&";
    if (beginTime !== undefined && beginTime !== null)
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime !== undefined && endTime !== null)
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSaleOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSaleOrders(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BuyOrder[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<BuyOrder[]>;
        })
      );
  }

  protected processGetSaleOrders(
    response: HttpResponseBase
  ): Observable<BuyOrder[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(BuyOrder.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSaleDashboardOrders(
    branchId: number,
    beginTime?: Date | null | undefined,
    endTime?: Date | null | undefined,
    httpContext?: HttpContext
  ): Observable<SaleBranches[]> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/root-sales?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (beginTime !== undefined && beginTime !== null)
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime !== undefined && endTime !== null)
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSaleDashboardOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSaleDashboardOrders(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SaleBranches[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SaleBranches[]
            >;
        })
      );
  }

  protected processGetSaleDashboardOrders(
    response: HttpResponseBase
  ): Observable<SaleBranches[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(SaleBranches.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  saleReturnOrder(
    branchId: number,
    orderId: number,
    httpContext?: HttpContext
  ): Observable<number> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/buy-orders/{orderId}/roll-back-order";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSaleReturnOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSaleReturnOrder(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processSaleReturnOrder(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSaleReturnOrder(
    branchId: number,
    saleReturnOrderId: number,
    httpContext?: HttpContext
  ): Observable<SaleReturnOrder> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/buy-orders/sale-return-orders/{saleReturnOrderId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (saleReturnOrderId === undefined || saleReturnOrderId === null)
      throw new Error("The parameter 'saleReturnOrderId' must be defined.");
    url_ = url_.replace(
      "{saleReturnOrderId}",
      encodeURIComponent("" + saleReturnOrderId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSaleReturnOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSaleReturnOrder(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SaleReturnOrder>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SaleReturnOrder>;
        })
      );
  }

  protected processGetSaleReturnOrder(
    response: HttpResponseBase
  ): Observable<SaleReturnOrder> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SaleReturnOrder.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSaleReturnOrders(
    branchId: number,
    buyOrderId?: number | null | undefined,
    beginTime?: Date | null | undefined,
    endTime?: Date | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<SaleReturnOrder[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/buy-orders/sale-return-orders?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (buyOrderId !== undefined && buyOrderId !== null)
      url_ += "buyOrderId=" + encodeURIComponent("" + buyOrderId) + "&";
    if (beginTime !== undefined && beginTime !== null)
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime !== undefined && endTime !== null)
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSaleReturnOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSaleReturnOrders(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SaleReturnOrder[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SaleReturnOrder[]
            >;
        })
      );
  }

  protected processGetSaleReturnOrders(
    response: HttpResponseBase
  ): Observable<SaleReturnOrder[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(SaleReturnOrder.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class CategoriesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    request: CreateCategoryRequest,
    httpContext?: HttpContext
  ): Observable<Category> {
    let url_ = this.baseUrl + "/api/v1/categories";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Category>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Category>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<Category> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Category.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createRoot(httpContext?: HttpContext): Observable<Category> {
    let url_ = this.baseUrl + "/api/v1/categories/root-category";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateRoot(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateRoot(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Category>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Category>;
        })
      );
  }

  protected processCreateRoot(
    response: HttpResponseBase
  ): Observable<Category> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Category.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getRootCategory(httpContext?: HttpContext): Observable<Category> {
    let url_ = this.baseUrl + "/api/v1/categories/root";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRootCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRootCategory(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Category>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Category>;
        })
      );
  }

  protected processGetRootCategory(
    response: HttpResponseBase
  ): Observable<Category> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Category.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    categoryId: number,
    request: UpdateCategoryRequest,
    httpContext?: HttpContext
  ): Observable<Category> {
    let url_ = this.baseUrl + "/api/v1/categories/{categoryId}";
    if (categoryId === undefined || categoryId === null)
      throw new Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Category>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Category>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<Category> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Category.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class CreditClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getCustomerCredits(
    merchantId: number,
    branchId: number,
    customerMerchantId: number,
    httpContext?: HttpContext
  ): Observable<Wallet> {
    let url_ =
      this.baseUrl +
      "/api/v1/merchants/{merchantId}/branches/{branchId}/customer-credit?";
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (customerMerchantId === undefined || customerMerchantId === null)
      throw new Error(
        "The parameter 'customerMerchantId' must be defined and cannot be null."
      );
    else
      url_ +=
        "customerMerchantId=" +
        encodeURIComponent("" + customerMerchantId) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCustomerCredits(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCustomerCredits(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Wallet>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Wallet>;
        })
      );
  }

  protected processGetCustomerCredits(
    response: HttpResponseBase
  ): Observable<Wallet> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Wallet.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getMyCredit(
    merchantId: number,
    branchId: number,
    httpContext?: HttpContext
  ): Observable<Wallet> {
    let url_ =
      this.baseUrl +
      "/api/v1/merchants/{merchantId}/branches/{branchId}/credit";
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMyCredit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMyCredit(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Wallet>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Wallet>;
        })
      );
  }

  protected processGetMyCredit(response: HttpResponseBase): Observable<Wallet> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Wallet.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCreditTransactions(
    merchantId: number,
    branchId: number,
    receiverMerchantId: number,
    creditTransactionType?: CreditTransactionType | null | undefined,
    beginTime?: Date | null | undefined,
    endTime?: Date | null | undefined,
    pageSize?: number | null | undefined,
    pageNumber?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<WalletTransaction[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/merchants/{merchantId}/branches/{branchId}/credit-transactions?";
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (receiverMerchantId === undefined || receiverMerchantId === null)
      throw new Error(
        "The parameter 'receiverMerchantId' must be defined and cannot be null."
      );
    else
      url_ +=
        "receiverMerchantId=" +
        encodeURIComponent("" + receiverMerchantId) +
        "&";
    if (creditTransactionType !== undefined && creditTransactionType !== null)
      url_ +=
        "creditTransactionType=" +
        encodeURIComponent("" + creditTransactionType) +
        "&";
    if (beginTime !== undefined && beginTime !== null)
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime !== undefined && endTime !== null)
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCreditTransactions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCreditTransactions(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                WalletTransaction[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              WalletTransaction[]
            >;
        })
      );
  }

  protected processGetCreditTransactions(
    response: HttpResponseBase
  ): Observable<WalletTransaction[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(WalletTransaction.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class CurrenciesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    currencyName: string,
    httpContext?: HttpContext
  ): Observable<Currency> {
    let url_ = this.baseUrl + "/api/v1/currencies?";
    if (currencyName === undefined || currencyName === null)
      throw new Error(
        "The parameter 'currencyName' must be defined and cannot be null."
      );
    else url_ += "currencyName=" + encodeURIComponent("" + currencyName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Currency>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Currency>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<Currency> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Currency.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCurrencies(httpContext?: HttpContext): Observable<Currency[]> {
    let url_ = this.baseUrl + "/api/v1/currencies";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrencies(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrencies(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Currency[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Currency[]>;
        })
      );
  }

  protected processGetCurrencies(
    response: HttpResponseBase
  ): Observable<Currency[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Currency.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    currencyId: number,
    currencyName: string,
    httpContext?: HttpContext
  ): Observable<Currency> {
    let url_ = this.baseUrl + "/api/v1/currencies/{currencyId}?";
    if (currencyId === undefined || currencyId === null)
      throw new Error("The parameter 'currencyId' must be defined.");
    url_ = url_.replace("{currencyId}", encodeURIComponent("" + currencyId));
    if (currencyName === undefined || currencyName === null)
      throw new Error(
        "The parameter 'currencyName' must be defined and cannot be null."
      );
    else url_ += "currencyName=" + encodeURIComponent("" + currencyName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Currency>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Currency>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<Currency> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Currency.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  refreshCurrencyExchangeRates(httpContext?: HttpContext): Observable<void> {
    let url_ =
      this.baseUrl + "/api/v1/currencies/refresh-currency-exchange-rates";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefreshCurrencyExchangeRates(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefreshCurrencyExchangeRates(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRefreshCurrencyExchangeRates(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createCurrencyExchangeRate(
    request: PutCurrencyExchangeRateRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/currencies/currency-exchange-rates";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateCurrencyExchangeRate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateCurrencyExchangeRate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processCreateCurrencyExchangeRate(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class FinancialClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    branchId: number,
    financialType: FinancialOrderType,
    financialRequest: FinancialRequest,
    httpContext?: HttpContext
  ): Observable<number> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/financial-order?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (financialType === undefined || financialType === null)
      throw new Error(
        "The parameter 'financialType' must be defined and cannot be null."
      );
    else
      url_ += "financialType=" + encodeURIComponent("" + financialType) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(financialRequest);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getFinancialOrders(
    branchId: number,
    customerMerchantId?: number | null | undefined,
    financialType?: FinancialOrderType | null | undefined,
    financialOrderState?: FinancialOrderState | null | undefined,
    beginTime?: Date | null | undefined,
    endTime?: Date | null | undefined,
    pageSize?: number | null | undefined,
    pageNumber?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<FinancialOrder[]> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/financial-order?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (customerMerchantId !== undefined && customerMerchantId !== null)
      url_ +=
        "customerMerchantId=" +
        encodeURIComponent("" + customerMerchantId) +
        "&";
    if (financialType !== undefined && financialType !== null)
      url_ += "financialType=" + encodeURIComponent("" + financialType) + "&";
    if (financialOrderState !== undefined && financialOrderState !== null)
      url_ +=
        "financialOrderState=" +
        encodeURIComponent("" + financialOrderState) +
        "&";
    if (beginTime !== undefined && beginTime !== null)
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime !== undefined && endTime !== null)
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialOrders(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FinancialOrder[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              FinancialOrder[]
            >;
        })
      );
  }

  protected processGetFinancialOrders(
    response: HttpResponseBase
  ): Observable<FinancialOrder[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(FinancialOrder.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  verify(
    branchId: number,
    financialType: FinancialOrderType,
    financialOrderId: number,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/financial-order/{financialOrderId}/verify?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (financialOrderId === undefined || financialOrderId === null)
      throw new Error("The parameter 'financialOrderId' must be defined.");
    url_ = url_.replace(
      "{financialOrderId}",
      encodeURIComponent("" + financialOrderId)
    );
    if (financialType === undefined || financialType === null)
      throw new Error(
        "The parameter 'financialType' must be defined and cannot be null."
      );
    else
      url_ += "financialType=" + encodeURIComponent("" + financialType) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processVerify(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processVerify(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processVerify(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  reject(
    branchId: number,
    financialType: FinancialOrderType,
    financialOrderId: number,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/financial-order/{financialOrderId}/reject?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (financialOrderId === undefined || financialOrderId === null)
      throw new Error("The parameter 'financialOrderId' must be defined.");
    url_ = url_.replace(
      "{financialOrderId}",
      encodeURIComponent("" + financialOrderId)
    );
    if (financialType === undefined || financialType === null)
      throw new Error(
        "The parameter 'financialType' must be defined and cannot be null."
      );
    else
      url_ += "financialType=" + encodeURIComponent("" + financialType) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processReject(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class GatewayListsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    branchId: number,
    request: CreateGatewayListRequest,
    httpContext?: HttpContext
  ): Observable<GatewayList> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<GatewayList>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GatewayList>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<GatewayList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GatewayList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  delete(
    branchId: number,
    gatewayListId: number,
    forceDelete?: boolean | null | undefined,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (gatewayListId === undefined || gatewayListId === null)
      throw new Error(
        "The parameter 'gatewayListId' must be defined and cannot be null."
      );
    else
      url_ += "gatewayListId=" + encodeURIComponent("" + gatewayListId) + "&";
    if (forceDelete !== undefined && forceDelete !== null)
      url_ += "forceDelete=" + encodeURIComponent("" + forceDelete) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getGatewayLists(
    branchId: number,
    httpContext?: HttpContext
  ): Observable<GatewayList[]> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGatewayLists(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGatewayLists(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<GatewayList[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              GatewayList[]
            >;
        })
      );
  }

  protected processGetGatewayLists(
    response: HttpResponseBase
  ): Observable<GatewayList[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(GatewayList.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(
    branchId: number,
    gatewayListId: number,
    httpContext?: HttpContext
  ): Observable<GatewayList> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/gateway-lists/{gatewayListId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (gatewayListId === undefined || gatewayListId === null)
      throw new Error("The parameter 'gatewayListId' must be defined.");
    url_ = url_.replace(
      "{gatewayListId}",
      encodeURIComponent("" + gatewayListId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<GatewayList>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GatewayList>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<GatewayList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GatewayList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  put(
    branchId: number,
    gatewayListId: number,
    request: PutGatewayListRequest,
    httpContext?: HttpContext
  ): Observable<GatewayList> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/gateway-lists/{gatewayListId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (gatewayListId === undefined || gatewayListId === null)
      throw new Error("The parameter 'gatewayListId' must be defined.");
    url_ = url_.replace(
      "{gatewayListId}",
      encodeURIComponent("" + gatewayListId)
    );
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<GatewayList>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GatewayList>;
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<GatewayList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GatewayList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAssignedMerchantsByGatewayListId(
    branchId: number,
    gatewayListId: number,
    httpContext?: HttpContext
  ): Observable<MerchantSummary[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/gateway-lists/{gatewayListId}/assigned-merchants";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (gatewayListId === undefined || gatewayListId === null)
      throw new Error("The parameter 'gatewayListId' must be defined.");
    url_ = url_.replace(
      "{gatewayListId}",
      encodeURIComponent("" + gatewayListId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAssignedMerchantsByGatewayListId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAssignedMerchantsByGatewayListId(
                response_ as any
              );
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                MerchantSummary[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              MerchantSummary[]
            >;
        })
      );
  }

  protected processGetAssignedMerchantsByGatewayListId(
    response: HttpResponseBase
  ): Observable<MerchantSummary[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(MerchantSummary.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getPaymentProfiles(
    branchId: number,
    httpContext?: HttpContext
  ): Observable<PaymentProfile[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/gateway-lists/payment-profiles";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPaymentProfiles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPaymentProfiles(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentProfile[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              PaymentProfile[]
            >;
        })
      );
  }

  protected processGetPaymentProfiles(
    response: HttpResponseBase
  ): Observable<PaymentProfile[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PaymentProfile.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  assignToMerchant(
    branchId: number,
    gatewayListId: number,
    subMerchantId: number,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/gateway-lists/{gatewayListId}/assign-merchant/{subMerchantId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (gatewayListId === undefined || gatewayListId === null)
      throw new Error("The parameter 'gatewayListId' must be defined.");
    url_ = url_.replace(
      "{gatewayListId}",
      encodeURIComponent("" + gatewayListId)
    );
    if (subMerchantId === undefined || subMerchantId === null)
      throw new Error("The parameter 'subMerchantId' must be defined.");
    url_ = url_.replace(
      "{subMerchantId}",
      encodeURIComponent("" + subMerchantId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssignToMerchant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssignToMerchant(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAssignToMerchant(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  unAssignFromMerchant(
    branchId: number,
    gatewayListId: number,
    subMerchantId: number,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/gateway-lists/{gatewayListId}/unassign-merchant/{subMerchantId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (gatewayListId === undefined || gatewayListId === null)
      throw new Error("The parameter 'gatewayListId' must be defined.");
    url_ = url_.replace(
      "{gatewayListId}",
      encodeURIComponent("" + gatewayListId)
    );
    if (subMerchantId === undefined || subMerchantId === null)
      throw new Error("The parameter 'subMerchantId' must be defined.");
    url_ = url_.replace(
      "{subMerchantId}",
      encodeURIComponent("" + subMerchantId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUnAssignFromMerchant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUnAssignFromMerchant(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUnAssignFromMerchant(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class InvoicesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getInvoices(
    merchantId: number,
    beginCreatedTime?: Date | null | undefined,
    endCreatedTime?: Date | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<InvoiceSummary[]> {
    let url_ = this.baseUrl + "/api/v1/merchants/{merchantId}/Invoices?";
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    if (beginCreatedTime !== undefined && beginCreatedTime !== null)
      url_ +=
        "beginCreatedTime=" +
        encodeURIComponent(
          beginCreatedTime ? "" + beginCreatedTime.toISOString() : ""
        ) +
        "&";
    if (endCreatedTime !== undefined && endCreatedTime !== null)
      url_ +=
        "endCreatedTime=" +
        encodeURIComponent(
          endCreatedTime ? "" + endCreatedTime.toISOString() : ""
        ) +
        "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetInvoices(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetInvoices(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<InvoiceSummary[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              InvoiceSummary[]
            >;
        })
      );
  }

  protected processGetInvoices(
    response: HttpResponseBase
  ): Observable<InvoiceSummary[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(InvoiceSummary.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getInvoice(
    merchantId: number,
    invoiceId: number,
    httpContext?: HttpContext
  ): Observable<Invoice> {
    let url_ =
      this.baseUrl + "/api/v1/merchants/{merchantId}/Invoices/{invoiceId}";
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    if (invoiceId === undefined || invoiceId === null)
      throw new Error("The parameter 'invoiceId' must be defined.");
    url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetInvoice(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetInvoice(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Invoice>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Invoice>;
        })
      );
  }

  protected processGetInvoice(response: HttpResponseBase): Observable<Invoice> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Invoice.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class MerchantCurrencyLimitsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  put(
    branchId: number,
    subMerchantId: number,
    request: CreateMerchantCurrencyLimitRequest,
    httpContext?: HttpContext
  ): Observable<MerchantCurrencyLimit> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/sub-merchants/{subMerchantId}/currency-limits";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (subMerchantId === undefined || subMerchantId === null)
      throw new Error("The parameter 'subMerchantId' must be defined.");
    url_ = url_.replace(
      "{subMerchantId}",
      encodeURIComponent("" + subMerchantId)
    );
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<MerchantCurrencyLimit>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<MerchantCurrencyLimit>;
        })
      );
  }

  protected processPut(
    response: HttpResponseBase
  ): Observable<MerchantCurrencyLimit> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = MerchantCurrencyLimit.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getMerchantCurrencyLimits(
    branchId: number,
    subMerchantId: number,
    httpContext?: HttpContext
  ): Observable<MerchantCurrencyLimit[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/sub-merchants/{subMerchantId}/currency-limits";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (subMerchantId === undefined || subMerchantId === null)
      throw new Error("The parameter 'subMerchantId' must be defined.");
    url_ = url_.replace(
      "{subMerchantId}",
      encodeURIComponent("" + subMerchantId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMerchantCurrencyLimits(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMerchantCurrencyLimits(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                MerchantCurrencyLimit[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              MerchantCurrencyLimit[]
            >;
        })
      );
  }

  protected processGetMerchantCurrencyLimits(
    response: HttpResponseBase
  ): Observable<MerchantCurrencyLimit[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(MerchantCurrencyLimit.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createRootMerchantCurrencyLimit(
    branchId: number,
    request: CreateMerchantCurrencyLimitRequest,
    httpContext?: HttpContext
  ): Observable<MerchantCurrencyLimit> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/root-currency-limits";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateRootMerchantCurrencyLimit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateRootMerchantCurrencyLimit(
                response_ as any
              );
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<MerchantCurrencyLimit>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<MerchantCurrencyLimit>;
        })
      );
  }

  protected processCreateRootMerchantCurrencyLimit(
    response: HttpResponseBase
  ): Observable<MerchantCurrencyLimit> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = MerchantCurrencyLimit.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    branchId: number,
    subMerchantId: number,
    currencyLimitId: number,
    amount: number,
    httpContext?: HttpContext
  ): Observable<MerchantCurrencyLimit> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/sub-merchants/{subMerchantId}/currency-limits/{currencyLimitId}?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (subMerchantId === undefined || subMerchantId === null)
      throw new Error("The parameter 'subMerchantId' must be defined.");
    url_ = url_.replace(
      "{subMerchantId}",
      encodeURIComponent("" + subMerchantId)
    );
    if (currencyLimitId === undefined || currencyLimitId === null)
      throw new Error("The parameter 'currencyLimitId' must be defined.");
    url_ = url_.replace(
      "{currencyLimitId}",
      encodeURIComponent("" + currencyLimitId)
    );
    if (amount === undefined || amount === null)
      throw new Error(
        "The parameter 'amount' must be defined and cannot be null."
      );
    else url_ += "amount=" + encodeURIComponent("" + amount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<MerchantCurrencyLimit>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<MerchantCurrencyLimit>;
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<MerchantCurrencyLimit> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = MerchantCurrencyLimit.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  delete(
    branchId: number,
    subMerchantId: number,
    currencyLimitId: number,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/sub-merchants/{subMerchantId}/currency-limits/{currencyLimitId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (subMerchantId === undefined || subMerchantId === null)
      throw new Error("The parameter 'subMerchantId' must be defined.");
    url_ = url_.replace(
      "{subMerchantId}",
      encodeURIComponent("" + subMerchantId)
    );
    if (currencyLimitId === undefined || currencyLimitId === null)
      throw new Error("The parameter 'currencyLimitId' must be defined.");
    url_ = url_.replace(
      "{currencyLimitId}",
      encodeURIComponent("" + currencyLimitId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class MerchantsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    branchId: number,
    request: CreateMerchantRequest,
    httpContext?: HttpContext
  ): Observable<MerchantLight> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/merchants";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<MerchantLight>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<MerchantLight>;
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<MerchantLight> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = MerchantLight.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(
    branchId: number,
    merchantId: number,
    includeSubBranches?: boolean | undefined,
    httpContext?: HttpContext
  ): Observable<Merchant> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/merchants/{merchantId}?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    if (includeSubBranches === null)
      throw new Error("The parameter 'includeSubBranches' cannot be null.");
    else if (includeSubBranches !== undefined)
      url_ +=
        "includeSubBranches=" +
        encodeURIComponent("" + includeSubBranches) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Merchant>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Merchant>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<Merchant> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Merchant.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    branchId: number,
    merchantId: number,
    request: UpdateMerchantRequest,
    httpContext?: HttpContext
  ): Observable<Merchant> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/merchants/{merchantId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Merchant>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Merchant>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<Merchant> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Merchant.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateMerchantSetting(
    branchId: number,
    merchantId: number,
    request: UpdateMerchantSettingRequest,
    httpContext?: HttpContext
  ): Observable<Merchant> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/merchants/{merchantId}/setting";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateMerchantSetting(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateMerchantSetting(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Merchant>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Merchant>;
        })
      );
  }

  protected processUpdateMerchantSetting(
    response: HttpResponseBase
  ): Observable<Merchant> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Merchant.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getPaymentProfiles(
    branchId: number,
    merchantId: number,
    httpContext?: HttpContext
  ): Observable<PaymentProfile[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/merchants/{merchantId}/payment-profiles";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPaymentProfiles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPaymentProfiles(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentProfile[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              PaymentProfile[]
            >;
        })
      );
  }

  protected processGetPaymentProfiles(
    response: HttpResponseBase
  ): Observable<PaymentProfile[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PaymentProfile.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class PaymentOrdersClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    branchId: number,
    request: CreatePaymentOrderRequest,
    httpContext?: HttpContext
  ): Observable<PaymentOrder> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/paymentOrders";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentOrder>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaymentOrder>;
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<PaymentOrder> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaymentOrder.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getPaymentOrders(
    branchId: number,
    paymentOrderStates?: string | null | undefined,
    beginTime?: Date | null | undefined,
    endTime?: Date | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<PaymentOrderSummary[]> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/paymentOrders?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (paymentOrderStates !== undefined && paymentOrderStates !== null)
      url_ +=
        "paymentOrderStates=" +
        encodeURIComponent("" + paymentOrderStates) +
        "&";
    if (beginTime !== undefined && beginTime !== null)
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime !== undefined && endTime !== null)
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPaymentOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPaymentOrders(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                PaymentOrderSummary[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              PaymentOrderSummary[]
            >;
        })
      );
  }

  protected processGetPaymentOrders(
    response: HttpResponseBase
  ): Observable<PaymentOrderSummary[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PaymentOrderSummary.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(
    branchId: number,
    paymentOrderId: number,
    httpContext?: HttpContext
  ): Observable<PaymentOrder> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/paymentOrders/{paymentOrderId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (paymentOrderId === undefined || paymentOrderId === null)
      throw new Error("The parameter 'paymentOrderId' must be defined.");
    url_ = url_.replace(
      "{paymentOrderId}",
      encodeURIComponent("" + paymentOrderId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentOrder>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaymentOrder>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<PaymentOrder> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaymentOrder.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  stateLogs(
    branchId: number,
    paymentOrderId: number,
    httpContext?: HttpContext
  ): Observable<PaymentOrderStateLog[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/paymentOrders/{paymentOrderId}/state-logs";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (paymentOrderId === undefined || paymentOrderId === null)
      throw new Error("The parameter 'paymentOrderId' must be defined.");
    url_ = url_.replace(
      "{paymentOrderId}",
      encodeURIComponent("" + paymentOrderId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processStateLogs(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processStateLogs(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                PaymentOrderStateLog[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              PaymentOrderStateLog[]
            >;
        })
      );
  }

  protected processStateLogs(
    response: HttpResponseBase
  ): Observable<PaymentOrderStateLog[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PaymentOrderStateLog.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class PriceListsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    branchId: number,
    request: CreatePriceListRequest,
    httpContext?: HttpContext
  ): Observable<PriceList> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PriceList>;
            }
          } else
            return _observableThrow(response_) as any as Observable<PriceList>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<PriceList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PriceList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByBranch(
    branchId: number,
    httpContext?: HttpContext
  ): Observable<PriceList> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByBranch(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByBranch(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PriceList>;
            }
          } else
            return _observableThrow(response_) as any as Observable<PriceList>;
        })
      );
  }

  protected processGetByBranch(
    response: HttpResponseBase
  ): Observable<PriceList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PriceList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getBuyPrices(
    branchId: number,
    searchCriteria?: string | null | undefined,
    productId?: number | null | undefined,
    currencyId?: number | null | undefined,
    categoryId?: number | null | undefined,
    isPhysicalProduct?: boolean | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<BuyPrice[]> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/price-lists/buy-prices?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    if (productId !== undefined && productId !== null)
      url_ += "productId=" + encodeURIComponent("" + productId) + "&";
    if (currencyId !== undefined && currencyId !== null)
      url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
    if (categoryId !== undefined && categoryId !== null)
      url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
    if (isPhysicalProduct !== undefined && isPhysicalProduct !== null)
      url_ +=
        "isPhysicalProduct=" + encodeURIComponent("" + isPhysicalProduct) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBuyPrices(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBuyPrices(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BuyPrice[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<BuyPrice[]>;
        })
      );
  }

  protected processGetBuyPrices(
    response: HttpResponseBase
  ): Observable<BuyPrice[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(BuyPrice.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(
    branchId: number,
    priceListId: number,
    httpContext?: HttpContext
  ): Observable<PriceList> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/price-lists/{priceListId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (priceListId === undefined || priceListId === null)
      throw new Error("The parameter 'priceListId' must be defined.");
    url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PriceList>;
            }
          } else
            return _observableThrow(response_) as any as Observable<PriceList>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<PriceList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PriceList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getPriceViews(
    branchId: number,
    priceListId: number,
    searchCriteria?: string | null | undefined,
    filterCurrencyId?: number | null | undefined,
    filterCategoryId?: number | null | undefined,
    isPhysicalProduct?: boolean | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<PriceView[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/price-lists/{priceListId}/price-views?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (priceListId === undefined || priceListId === null)
      throw new Error("The parameter 'priceListId' must be defined.");
    url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    if (filterCurrencyId !== undefined && filterCurrencyId !== null)
      url_ +=
        "filterCurrencyId=" + encodeURIComponent("" + filterCurrencyId) + "&";
    if (filterCategoryId !== undefined && filterCategoryId !== null)
      url_ +=
        "filterCategoryId=" + encodeURIComponent("" + filterCategoryId) + "&";
    if (isPhysicalProduct !== undefined && isPhysicalProduct !== null)
      url_ +=
        "isPhysicalProduct=" + encodeURIComponent("" + isPhysicalProduct) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPriceViews(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPriceViews(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PriceView[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              PriceView[]
            >;
        })
      );
  }

  protected processGetPriceViews(
    response: HttpResponseBase
  ): Observable<PriceView[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PriceView.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getPrices(
    branchId: number,
    priceListId: number,
    searchCriteria?: string | null | undefined,
    filterCurrencyId?: number | null | undefined,
    filterCategoryId?: number | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<PriceView[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/price-lists/{priceListId}/prices?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (priceListId === undefined || priceListId === null)
      throw new Error("The parameter 'priceListId' must be defined.");
    url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    if (filterCurrencyId !== undefined && filterCurrencyId !== null)
      url_ +=
        "filterCurrencyId=" + encodeURIComponent("" + filterCurrencyId) + "&";
    if (filterCategoryId !== undefined && filterCategoryId !== null)
      url_ +=
        "filterCategoryId=" + encodeURIComponent("" + filterCategoryId) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPrices(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPrices(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PriceView[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              PriceView[]
            >;
        })
      );
  }

  protected processGetPrices(
    response: HttpResponseBase
  ): Observable<PriceView[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PriceView.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  setPrices(
    branchId: number,
    priceListId: number,
    priceRules: ProductPriceRule[],
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/price-lists/{priceListId}/prices";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (priceListId === undefined || priceListId === null)
      throw new Error("The parameter 'priceListId' must be defined.");
    url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(priceRules);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetPrices(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetPrices(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSetPrices(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getPriceRulesByProduct(
    branchId: number,
    priceListId: number,
    productId: number,
    httpContext?: HttpContext
  ): Observable<Price> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/price-lists/{priceListId}/prices/productId:{productId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (priceListId === undefined || priceListId === null)
      throw new Error("The parameter 'priceListId' must be defined.");
    url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPriceRulesByProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPriceRulesByProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Price>;
            }
          } else return _observableThrow(response_) as any as Observable<Price>;
        })
      );
  }

  protected processGetPriceRulesByProduct(
    response: HttpResponseBase
  ): Observable<Price> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Price.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deletePriceRulesByProduct(
    branchId: number,
    priceListId: number,
    productId: number,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/price-lists/{priceListId}/prices/productId:{productId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (priceListId === undefined || priceListId === null)
      throw new Error("The parameter 'priceListId' must be defined.");
    url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeletePriceRulesByProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeletePriceRulesByProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDeletePriceRulesByProduct(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  setPriceRulesByProduct(
    branchId: number,
    priceListId: number,
    productId: number,
    priceRules: PriceRule[],
    preview?: boolean | undefined,
    httpContext?: HttpContext
  ): Observable<PriceView> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/price-lists/{priceListId}/prices/productId:{productId}?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (priceListId === undefined || priceListId === null)
      throw new Error("The parameter 'priceListId' must be defined.");
    url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (preview === null)
      throw new Error("The parameter 'preview' cannot be null.");
    else if (preview !== undefined)
      url_ += "preview=" + encodeURIComponent("" + preview) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(priceRules);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetPriceRulesByProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetPriceRulesByProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PriceView>;
            }
          } else
            return _observableThrow(response_) as any as Observable<PriceView>;
        })
      );
  }

  protected processSetPriceRulesByProduct(
    response: HttpResponseBase
  ): Observable<PriceView> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PriceView.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class ProductsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    request: CreateProductRequest,
    httpContext?: HttpContext
  ): Observable<Product> {
    let url_ = this.baseUrl + "/api/v1/products";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Product>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Product>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<Product> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Product.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getProducts(
    searchCriteria?: string | null | undefined,
    filterCurrencyId?: number | null | undefined,
    filterCategoryId?: number | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<ProductSummary[]> {
    let url_ = this.baseUrl + "/api/v1/products?";
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    if (filterCurrencyId !== undefined && filterCurrencyId !== null)
      url_ +=
        "filterCurrencyId=" + encodeURIComponent("" + filterCurrencyId) + "&";
    if (filterCategoryId !== undefined && filterCategoryId !== null)
      url_ +=
        "filterCategoryId=" + encodeURIComponent("" + filterCategoryId) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProducts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProducts(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductSummary[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ProductSummary[]
            >;
        })
      );
  }

  protected processGetProducts(
    response: HttpResponseBase
  ): Observable<ProductSummary[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ProductSummary.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  sync(httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/products/sync";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSync(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSync(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSync(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    productId: number,
    request: UpdateProductRequest,
    httpContext?: HttpContext
  ): Observable<Product> {
    let url_ = this.baseUrl + "/api/v1/products/{productId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Product>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Product>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<Product> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Product.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(productId: number, httpContext?: HttpContext): Observable<Product> {
    let url_ = this.baseUrl + "/api/v1/products/{productId}";
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Product>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Product>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<Product> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Product.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAvailableProductItems(
    productId?: number | null | undefined,
    currencyId?: number | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<ProductItem[]> {
    let url_ = this.baseUrl + "/api/v1/products/available-items?";
    if (productId !== undefined && productId !== null)
      url_ += "productId=" + encodeURIComponent("" + productId) + "&";
    if (currencyId !== undefined && currencyId !== null)
      url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAvailableProductItems(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAvailableProductItems(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductItem[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ProductItem[]
            >;
        })
      );
  }

  protected processGetAvailableProductItems(
    response: HttpResponseBase
  ): Observable<ProductItem[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ProductItem.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class RegionsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    request: CreateRegionRequest,
    httpContext?: HttpContext
  ): Observable<Region> {
    let url_ = this.baseUrl + "/api/v1/regions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Region>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Region>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<Region> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Region.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getRegions(
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<Region[]> {
    let url_ = this.baseUrl + "/api/v1/regions?";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRegions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRegions(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Region[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Region[]>;
        })
      );
  }

  protected processGetRegions(
    response: HttpResponseBase
  ): Observable<Region[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Region.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(regionId: number, httpContext?: HttpContext): Observable<Region> {
    let url_ = this.baseUrl + "/api/v1/regions/{regionId}";
    if (regionId === undefined || regionId === null)
      throw new Error("The parameter 'regionId' must be defined.");
    url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Region>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Region>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<Region> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Region.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    regionId: number,
    request: UpdateRegionRequest,
    httpContext?: HttpContext
  ): Observable<Region> {
    let url_ = this.baseUrl + "/api/v1/regions/{regionId}";
    if (regionId === undefined || regionId === null)
      throw new Error("The parameter 'regionId' must be defined.");
    url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Region>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Region>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<Region> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Region.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class ReportsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  report(
    branchId: number,
    beginTime: Date,
    endTime: Date,
    httpContext?: HttpContext
  ): Observable<Report> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/reports/report?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (beginTime === undefined || beginTime === null)
      throw new Error(
        "The parameter 'beginTime' must be defined and cannot be null."
      );
    else
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime === undefined || endTime === null)
      throw new Error(
        "The parameter 'endTime' must be defined and cannot be null."
      );
    else
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReport(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReport(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Report>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Report>;
        })
      );
  }

  protected processReport(response: HttpResponseBase): Observable<Report> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Report.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  reportSummary(
    branchId: number,
    beginTime: Date,
    endTime: Date,
    httpContext?: HttpContext
  ): Observable<ReportSummary[]> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/reports/report-summary?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (beginTime === undefined || beginTime === null)
      throw new Error(
        "The parameter 'beginTime' must be defined and cannot be null."
      );
    else
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime === undefined || endTime === null)
      throw new Error(
        "The parameter 'endTime' must be defined and cannot be null."
      );
    else
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReportSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReportSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ReportSummary[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ReportSummary[]
            >;
        })
      );
  }

  protected processReportSummary(
    response: HttpResponseBase
  ): Observable<ReportSummary[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ReportSummary.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class SaleManagersClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  create(
    branchId: number,
    request: CreateSaleManagerRequest,
    httpContext?: HttpContext
  ): Observable<SaleManager> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sale-managers";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SaleManager>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SaleManager>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<SaleManager> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SaleManager.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSaleManagers(
    branchId: number,
    isActive?: boolean | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<SaleManager[]> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sale-managers?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (isActive !== undefined && isActive !== null)
      url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSaleManagers(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSaleManagers(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SaleManager[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SaleManager[]
            >;
        })
      );
  }

  protected processGetSaleManagers(
    response: HttpResponseBase
  ): Observable<SaleManager[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(SaleManager.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(
    branchId: number,
    saleManagerId: number,
    httpContext?: HttpContext
  ): Observable<SaleManager> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/sale-managers/{saleManagerId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (saleManagerId === undefined || saleManagerId === null)
      throw new Error("The parameter 'saleManagerId' must be defined.");
    url_ = url_.replace(
      "{saleManagerId}",
      encodeURIComponent("" + saleManagerId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SaleManager>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SaleManager>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<SaleManager> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SaleManager.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    branchId: number,
    saleManagerId: number,
    request: UpdateSaleManagerRequest,
    httpContext?: HttpContext
  ): Observable<SaleManager> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/sale-managers/{saleManagerId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (saleManagerId === undefined || saleManagerId === null)
      throw new Error("The parameter 'saleManagerId' must be defined.");
    url_ = url_.replace(
      "{saleManagerId}",
      encodeURIComponent("" + saleManagerId)
    );
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SaleManager>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SaleManager>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<SaleManager> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SaleManager.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  assignMerchants(
    branchId: number,
    saleManagerId: number,
    merchantIds: number[],
    forceAssign?: boolean | undefined,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/sale-managers/{saleManagerId}/assign-merchants?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (saleManagerId === undefined || saleManagerId === null)
      throw new Error("The parameter 'saleManagerId' must be defined.");
    url_ = url_.replace(
      "{saleManagerId}",
      encodeURIComponent("" + saleManagerId)
    );
    if (forceAssign === null)
      throw new Error("The parameter 'forceAssign' cannot be null.");
    else if (forceAssign !== undefined)
      url_ += "forceAssign=" + encodeURIComponent("" + forceAssign) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(merchantIds);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssignMerchants(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssignMerchants(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAssignMerchants(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  unAssignMerchant(
    branchId: number,
    saleManagerId: number,
    merchantId: number,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/sale-managers/{saleManagerId}/unAssign-merchant/{merchantId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (saleManagerId === undefined || saleManagerId === null)
      throw new Error("The parameter 'saleManagerId' must be defined.");
    url_ = url_.replace(
      "{saleManagerId}",
      encodeURIComponent("" + saleManagerId)
    );
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUnAssignMerchant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUnAssignMerchant(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUnAssignMerchant(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSaleReport(
    branchId: number,
    saleManagerId: number,
    beginTime: Date,
    endTime: Date,
    httpContext?: HttpContext
  ): Observable<SaleManagerAccountingReport[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/sale-managers/{saleManagerId}/sale-report?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (saleManagerId === undefined || saleManagerId === null)
      throw new Error("The parameter 'saleManagerId' must be defined.");
    url_ = url_.replace(
      "{saleManagerId}",
      encodeURIComponent("" + saleManagerId)
    );
    if (beginTime === undefined || beginTime === null)
      throw new Error(
        "The parameter 'beginTime' must be defined and cannot be null."
      );
    else
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime === undefined || endTime === null)
      throw new Error(
        "The parameter 'endTime' must be defined and cannot be null."
      );
    else
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSaleReport(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSaleReport(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                SaleManagerAccountingReport[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              SaleManagerAccountingReport[]
            >;
        })
      );
  }

  protected processGetSaleReport(
    response: HttpResponseBase
  ): Observable<SaleManagerAccountingReport[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(SaleManagerAccountingReport.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class SystemClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  assignMerchantToMerchant(
    branchId: number,
    merchantId: number,
    targetBranchId: number,
    targetMerchantId: string,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/system/merchants/{merchantId}/assign-to-merchant/{targetMerchantId}?";
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    if (targetMerchantId === undefined || targetMerchantId === null)
      throw new Error("The parameter 'targetMerchantId' must be defined.");
    url_ = url_.replace(
      "{targetMerchantId}",
      encodeURIComponent("" + targetMerchantId)
    );
    if (branchId === undefined || branchId === null)
      throw new Error(
        "The parameter 'branchId' must be defined and cannot be null."
      );
    else url_ += "branchId=" + encodeURIComponent("" + branchId) + "&";
    if (targetBranchId === undefined || targetBranchId === null)
      throw new Error(
        "The parameter 'targetBranchId' must be defined and cannot be null."
      );
    else
      url_ += "targetBranchId=" + encodeURIComponent("" + targetBranchId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssignMerchantToMerchant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssignMerchantToMerchant(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAssignMerchantToMerchant(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateSetting(
    request: UpdateSettingRequest,
    httpContext?: HttpContext
  ): Observable<SettingModel> {
    let url_ = this.baseUrl + "/api/v1/system";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateSetting(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateSetting(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SettingModel>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SettingModel>;
        })
      );
  }

  protected processUpdateSetting(
    response: HttpResponseBase
  ): Observable<SettingModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SettingModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  uploadImage(
    image: FileParameter,
    httpContext?: HttpContext
  ): Observable<string> {
    let url_ = this.baseUrl + "/api/v1/system/upload-image";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (image === null || image === undefined)
      throw new Error("The parameter 'image' cannot be null.");
    else
      content_.append(
        "Image",
        image.data,
        image.fileName ? image.fileName : "Image"
      );

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadImage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadImage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string>;
            }
          } else
            return _observableThrow(response_) as any as Observable<string>;
        })
      );
  }

  protected processUploadImage(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSystemRootPriceList(httpContext?: HttpContext): Observable<PriceList> {
    let url_ = this.baseUrl + "/api/v1/system/system-root-price-list";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSystemRootPriceList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSystemRootPriceList(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PriceList>;
            }
          } else
            return _observableThrow(response_) as any as Observable<PriceList>;
        })
      );
  }

  protected processGetSystemRootPriceList(
    response: HttpResponseBase
  ): Observable<PriceList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PriceList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  clearAll(httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/system/clear-all";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processClearAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processClearAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processClearAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createRootMerchant(httpContext?: HttpContext): Observable<MerchantLight> {
    let url_ = this.baseUrl + "/api/v1/system/root-merchant";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateRootMerchant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateRootMerchant(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<MerchantLight>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<MerchantLight>;
        })
      );
  }

  protected processCreateRootMerchant(
    response: HttpResponseBase
  ): Observable<MerchantLight> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = MerchantLight.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getPaymentProfiles(httpContext?: HttpContext): Observable<PaymentProfile[]> {
    let url_ = this.baseUrl + "/api/v1/system/payment-profiles";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPaymentProfiles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPaymentProfiles(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentProfile[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              PaymentProfile[]
            >;
        })
      );
  }

  protected processGetPaymentProfiles(
    response: HttpResponseBase
  ): Observable<PaymentProfile[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(PaymentProfile.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createPaymentProfile(
    request: CreatePaymentProfileRequest,
    httpContext?: HttpContext
  ): Observable<PaymentProfile> {
    let url_ = this.baseUrl + "/api/v1/system/payment-profiles";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreatePaymentProfile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreatePaymentProfile(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentProfile>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaymentProfile>;
        })
      );
  }

  protected processCreatePaymentProfile(
    response: HttpResponseBase
  ): Observable<PaymentProfile> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaymentProfile.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updatePaymentProfile(
    paymentProfileId: number,
    request: UpdatePaymentProfileRequest,
    httpContext?: HttpContext
  ): Observable<PaymentProfile> {
    let url_ = this.baseUrl + "/api/v1/system/payment-profiles?";
    if (paymentProfileId === undefined || paymentProfileId === null)
      throw new Error(
        "The parameter 'paymentProfileId' must be defined and cannot be null."
      );
    else
      url_ +=
        "paymentProfileId=" + encodeURIComponent("" + paymentProfileId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdatePaymentProfile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdatePaymentProfile(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaymentProfile>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaymentProfile>;
        })
      );
  }

  protected processUpdatePaymentProfile(
    response: HttpResponseBase
  ): Observable<PaymentProfile> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaymentProfile.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getRootBranches(
    searchCriteria?: string | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<BranchLight[]> {
    let url_ = this.baseUrl + "/api/v1/system/merchants?";
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRootBranches(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRootBranches(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BranchLight[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              BranchLight[]
            >;
        })
      );
  }

  protected processGetRootBranches(
    response: HttpResponseBase
  ): Observable<BranchLight[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(BranchLight.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class TeamClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getMerchantsBranch(httpContext?: HttpContext): Observable<Branch[]> {
    let url_ = this.baseUrl + "/api/v1/team/users/current/branches";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMerchantsBranch(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMerchantsBranch(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Branch[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Branch[]>;
        })
      );
  }

  protected processGetMerchantsBranch(
    response: HttpResponseBase
  ): Observable<Branch[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Branch.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  listCurrentUserResources(httpContext?: HttpContext): Observable<string[]> {
    let url_ = this.baseUrl + "/api/v1/team/users/current/resources";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processListCurrentUserResources(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processListCurrentUserResources(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<string[]>;
        })
      );
  }

  protected processListCurrentUserResources(
    response: HttpResponseBase
  ): Observable<string[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(item);
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  listCurrentUserPermissions(
    resourceId: string,
    httpContext?: HttpContext
  ): Observable<string[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/team/users/current/resources/{resourceId}/permissions";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processListCurrentUserPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processListCurrentUserPermissions(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<string[]>;
        })
      );
  }

  protected processListCurrentUserPermissions(
    response: HttpResponseBase
  ): Observable<string[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(item);
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  resetBotApiKey(
    userId: string,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/team/users/{userId}/bot/reset-api-key";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetBotApiKey(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetBotApiKey(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processResetBotApiKey(
    response: HttpResponseBase
  ): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateBot(
    userId: string,
    updateParam: TeamUpdateBotParam,
    httpContext?: HttpContext
  ): Observable<User> {
    let url_ = this.baseUrl + "/api/v1/team/users/{userId}/bot";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(updateParam);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateBot(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateBot(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<User>;
            }
          } else return _observableThrow(response_) as any as Observable<User>;
        })
      );
  }

  protected processUpdateBot(response: HttpResponseBase): Observable<User> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = User.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  listRoles(resourceId: string, httpContext?: HttpContext): Observable<Role[]> {
    let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processListRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processListRoles(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Role[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Role[]>;
        })
      );
  }

  protected processListRoles(response: HttpResponseBase): Observable<Role[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(Role.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  listUserRoles(
    resourceId: string,
    roleId?: string | null | undefined,
    userId?: string | null | undefined,
    search?: string | null | undefined,
    isBot?: boolean | null | undefined,
    recordIndex?: number | undefined,
    recordCount?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<ListResultOfUserRole> {
    let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/user-roles?";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (roleId !== undefined && roleId !== null)
      url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
    if (userId !== undefined && userId !== null)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    if (search !== undefined && search !== null)
      url_ += "search=" + encodeURIComponent("" + search) + "&";
    if (isBot !== undefined && isBot !== null)
      url_ += "isBot=" + encodeURIComponent("" + isBot) + "&";
    if (recordIndex === null)
      throw new Error("The parameter 'recordIndex' cannot be null.");
    else if (recordIndex !== undefined)
      url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
    if (recordCount !== undefined && recordCount !== null)
      url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processListUserRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processListUserRoles(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ListResultOfUserRole>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ListResultOfUserRole>;
        })
      );
  }

  protected processListUserRoles(
    response: HttpResponseBase
  ): Observable<ListResultOfUserRole> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultOfUserRole.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  addNewBot(
    resourceId: string,
    roleId: string,
    addParam: TeamAddBotParam,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ =
      this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/bots";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (roleId === undefined || roleId === null)
      throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(addParam);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddNewBot(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddNewBot(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processAddNewBot(response: HttpResponseBase): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  addUserByEmail(
    resourceId: string,
    roleId: string,
    email: string,
    addParam?: TeamAddEmailParam | undefined,
    httpContext?: HttpContext
  ): Observable<UserRole> {
    let url_ =
      this.baseUrl +
      "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/email:{email}";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (roleId === undefined || roleId === null)
      throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
    if (email === undefined || email === null)
      throw new Error("The parameter 'email' must be defined.");
    url_ = url_.replace("{email}", encodeURIComponent("" + email));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(addParam);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddUserByEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddUserByEmail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserRole>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserRole>;
        })
      );
  }

  protected processAddUserByEmail(
    response: HttpResponseBase
  ): Observable<UserRole> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserRole.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  addUser(
    resourceId: string,
    roleId: string,
    userId: string,
    httpContext?: HttpContext
  ): Observable<UserRole> {
    let url_ =
      this.baseUrl +
      "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (roleId === undefined || roleId === null)
      throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserRole>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserRole>;
        })
      );
  }

  protected processAddUser(response: HttpResponseBase): Observable<UserRole> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserRole.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  removeUser(
    resourceId: string,
    roleId: string,
    userId: string,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (roleId === undefined || roleId === null)
      throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRemoveUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createSystemApiKey(
    secret: string,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/team/system/api-key";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (secret === null || secret === undefined)
      throw new Error("The parameter 'secret' cannot be null.");
    else content_.append("secret", secret.toString());

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateSystemApiKey(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateSystemApiKey(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processCreateSystemApiKey(
    response: HttpResponseBase
  ): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class WalletsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getWallet(branchId: number, httpContext?: HttpContext): Observable<Wallet> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/wallets/wallet";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetWallet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetWallet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Wallet>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Wallet>;
        })
      );
  }

  protected processGetWallet(response: HttpResponseBase): Observable<Wallet> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Wallet.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCustomerWallet(
    branchId: number,
    customerMerchantId: number,
    httpContext?: HttpContext
  ): Observable<Wallet> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/wallets/customer-wallet?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (customerMerchantId === undefined || customerMerchantId === null)
      throw new Error(
        "The parameter 'customerMerchantId' must be defined and cannot be null."
      );
    else
      url_ +=
        "customerMerchantId=" +
        encodeURIComponent("" + customerMerchantId) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCustomerWallet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCustomerWallet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Wallet>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Wallet>;
        })
      );
  }

  protected processGetCustomerWallet(
    response: HttpResponseBase
  ): Observable<Wallet> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Wallet.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getWalletTransactions(
    branchId: number,
    beginTime?: Date | null | undefined,
    endTime?: Date | null | undefined,
    subMerchantId?: number | null | undefined,
    transferWalletType?: TransferWalletType | null | undefined,
    currencyId?: number | null | undefined,
    pageSize?: number | null | undefined,
    pageNumber?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<WalletTransaction[]> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/wallets/transactions?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (beginTime !== undefined && beginTime !== null)
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime !== undefined && endTime !== null)
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    if (subMerchantId !== undefined && subMerchantId !== null)
      url_ += "subMerchantId=" + encodeURIComponent("" + subMerchantId) + "&";
    if (transferWalletType !== undefined && transferWalletType !== null)
      url_ +=
        "transferWalletType=" +
        encodeURIComponent("" + transferWalletType) +
        "&";
    if (currencyId !== undefined && currencyId !== null)
      url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetWalletTransactions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetWalletTransactions(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                WalletTransaction[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              WalletTransaction[]
            >;
        })
      );
  }

  protected processGetWalletTransactions(
    response: HttpResponseBase
  ): Observable<WalletTransaction[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(WalletTransaction.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class WebhookClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  catchPaymentProviderWebhook(
    webhookKey: string,
    httpContext?: HttpContext
  ): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/api/v1/webhooks/payment-provider-webhook?";
    if (webhookKey === undefined || webhookKey === null)
      throw new Error(
        "The parameter 'webhookKey' must be defined and cannot be null."
      );
    else url_ += "webhookKey=" + encodeURIComponent("" + webhookKey) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCatchPaymentProviderWebhook(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCatchPaymentProviderWebhook(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<FileResponse | null>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<FileResponse | null>;
        })
      );
  }

  protected processCatchPaymentProviderWebhook(
    response: HttpResponseBase
  ): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AuthenticationClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getCurrentUser(httpContext?: HttpContext): Observable<User> {
    let url_ = this.baseUrl + "/api/v1/authentication/current";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrentUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrentUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<User>;
            }
          } else return _observableThrow(response_) as any as Observable<User>;
        })
      );
  }

  protected processGetCurrentUser(
    response: HttpResponseBase
  ): Observable<User> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = User.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  signOutAll(httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/authentication/current/signout-all";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSignOutAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSignOutAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSignOutAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  resetCurrentUserApiKey(httpContext?: HttpContext): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/authentication/current/reset-api-key";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetCurrentUserApiKey(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetCurrentUserApiKey(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processResetCurrentUserApiKey(
    response: HttpResponseBase
  ): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  signIn(
    request: SignInRequest,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/authentication/signin";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSignIn(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSignIn(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processSignIn(response: HttpResponseBase): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  signUp(
    request: SignUpRequest,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/authentication/signup";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSignUp(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSignUp(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processSignUp(response: HttpResponseBase): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  refreshToken(
    request: RefreshTokenRequest,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/authentication/refresh-token";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefreshToken(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefreshToken(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processRefreshToken(
    response: HttpResponseBase
  ): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  googleSignInHandler(
    httpContext?: HttpContext
  ): Observable<FileResponse | null> {
    let url_ =
      this.baseUrl + "/api/v1/authentication/external/google/signin-handler";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGoogleSignInHandler(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGoogleSignInHandler(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<FileResponse | null>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<FileResponse | null>;
        })
      );
  }

  protected processGoogleSignInHandler(
    response: HttpResponseBase
  ): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getGoogleSignInUrl(
    csrfToken: string,
    nonce?: string | null | undefined,
    httpContext?: HttpContext
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/v1/authentication/external/google/signin-url?";
    if (csrfToken === undefined || csrfToken === null)
      throw new Error(
        "The parameter 'csrfToken' must be defined and cannot be null."
      );
    else url_ += "csrfToken=" + encodeURIComponent("" + csrfToken) + "&";
    if (nonce !== undefined && nonce !== null)
      url_ += "nonce=" + encodeURIComponent("" + nonce) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGoogleSignInUrl(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGoogleSignInUrl(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string>;
            }
          } else
            return _observableThrow(response_) as any as Observable<string>;
        })
      );
  }

  protected processGetGoogleSignInUrl(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export class Bank implements IBank {
  bankId!: number;
  bankName!: string;

  constructor(data?: IBank) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.bankId = _data["bankId"] !== undefined ? _data["bankId"] : <any>null;
      this.bankName =
        _data["bankName"] !== undefined ? _data["bankName"] : <any>null;
    }
  }

  static fromJS(data: any): Bank {
    data = typeof data === "object" ? data : {};
    let result = new Bank();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["bankId"] = this.bankId !== undefined ? this.bankId : <any>null;
    data["bankName"] = this.bankName !== undefined ? this.bankName : <any>null;
    return data;
  }
}

export interface IBank {
  bankId: number;
  bankName: string;
}

export class BranchLight implements IBranchLight {
  branchId!: number;
  branchName!: string;
  merchantId!: number;
  merchantName!: string;
  parentBranchId?: number | null;
  description?: string | null;
  isActive!: boolean;
  rootPriceListId?: number | null;
  canSetFaceValue!: boolean;
  canSetBuyValue!: boolean;
  canCreatePaymentOrder!: boolean;
  canPlaceOrder!: boolean;
  middlePriceList?: PriceListSummary | null;
  assignedPriceList?: PriceListSummary | null;
  merchant?: MerchantLight | null;

  constructor(data?: IBranchLight) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.branchName =
        _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.merchantName =
        _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
      this.parentBranchId =
        _data["parentBranchId"] !== undefined
          ? _data["parentBranchId"]
          : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.rootPriceListId =
        _data["rootPriceListId"] !== undefined
          ? _data["rootPriceListId"]
          : <any>null;
      this.canSetFaceValue =
        _data["canSetFaceValue"] !== undefined
          ? _data["canSetFaceValue"]
          : <any>null;
      this.canSetBuyValue =
        _data["canSetBuyValue"] !== undefined
          ? _data["canSetBuyValue"]
          : <any>null;
      this.canCreatePaymentOrder =
        _data["canCreatePaymentOrder"] !== undefined
          ? _data["canCreatePaymentOrder"]
          : <any>null;
      this.canPlaceOrder =
        _data["canPlaceOrder"] !== undefined
          ? _data["canPlaceOrder"]
          : <any>null;
      this.middlePriceList = _data["middlePriceList"]
        ? PriceListSummary.fromJS(_data["middlePriceList"])
        : <any>null;
      this.assignedPriceList = _data["assignedPriceList"]
        ? PriceListSummary.fromJS(_data["assignedPriceList"])
        : <any>null;
      this.merchant = _data["merchant"]
        ? MerchantLight.fromJS(_data["merchant"])
        : <any>null;
    }
  }

  static fromJS(data: any): BranchLight {
    data = typeof data === "object" ? data : {};
    let result = new BranchLight();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["branchName"] =
      this.branchName !== undefined ? this.branchName : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["merchantName"] =
      this.merchantName !== undefined ? this.merchantName : <any>null;
    data["parentBranchId"] =
      this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["rootPriceListId"] =
      this.rootPriceListId !== undefined ? this.rootPriceListId : <any>null;
    data["canSetFaceValue"] =
      this.canSetFaceValue !== undefined ? this.canSetFaceValue : <any>null;
    data["canSetBuyValue"] =
      this.canSetBuyValue !== undefined ? this.canSetBuyValue : <any>null;
    data["canCreatePaymentOrder"] =
      this.canCreatePaymentOrder !== undefined
        ? this.canCreatePaymentOrder
        : <any>null;
    data["canPlaceOrder"] =
      this.canPlaceOrder !== undefined ? this.canPlaceOrder : <any>null;
    data["middlePriceList"] = this.middlePriceList
      ? this.middlePriceList.toJSON()
      : <any>null;
    data["assignedPriceList"] = this.assignedPriceList
      ? this.assignedPriceList.toJSON()
      : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    return data;
  }
}

export interface IBranchLight {
  branchId: number;
  branchName: string;
  merchantId: number;
  merchantName: string;
  parentBranchId?: number | null;
  description?: string | null;
  isActive: boolean;
  rootPriceListId?: number | null;
  canSetFaceValue: boolean;
  canSetBuyValue: boolean;
  canCreatePaymentOrder: boolean;
  canPlaceOrder: boolean;
  middlePriceList?: PriceListSummary | null;
  assignedPriceList?: PriceListSummary | null;
  merchant?: MerchantLight | null;
}

export class PriceListSummary implements IPriceListSummary {
  priceListId!: number;
  priceListName?: string | null;

  constructor(data?: IPriceListSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.priceListId =
        _data["priceListId"] !== undefined ? _data["priceListId"] : <any>null;
      this.priceListName =
        _data["priceListName"] !== undefined
          ? _data["priceListName"]
          : <any>null;
    }
  }

  static fromJS(data: any): PriceListSummary {
    data = typeof data === "object" ? data : {};
    let result = new PriceListSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["priceListId"] =
      this.priceListId !== undefined ? this.priceListId : <any>null;
    data["priceListName"] =
      this.priceListName !== undefined ? this.priceListName : <any>null;
    return data;
  }
}

export interface IPriceListSummary {
  priceListId: number;
  priceListName?: string | null;
}

export class MerchantLight implements IMerchantLight {
  merchantId!: number;
  merchantName!: string;
  parentBranchId?: number | null;
  rootBranchId?: number | null;
  description?: string | null;
  isActive!: boolean;
  email!: string;
  walletId!: number;
  creditWalletId?: number | null;
  externalReference!: string;
  exchangeTargetCurrency!: Currency;
  saleManager?: SaleManagerSummary | null;
  invoiceThresholdDay?: number | null;

  constructor(data?: IMerchantLight) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.exchangeTargetCurrency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.merchantName =
        _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
      this.parentBranchId =
        _data["parentBranchId"] !== undefined
          ? _data["parentBranchId"]
          : <any>null;
      this.rootBranchId =
        _data["rootBranchId"] !== undefined ? _data["rootBranchId"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.walletId =
        _data["walletId"] !== undefined ? _data["walletId"] : <any>null;
      this.creditWalletId =
        _data["creditWalletId"] !== undefined
          ? _data["creditWalletId"]
          : <any>null;
      this.externalReference =
        _data["externalReference"] !== undefined
          ? _data["externalReference"]
          : <any>null;
      this.exchangeTargetCurrency = _data["exchangeTargetCurrency"]
        ? Currency.fromJS(_data["exchangeTargetCurrency"])
        : new Currency();
      this.saleManager = _data["saleManager"]
        ? SaleManagerSummary.fromJS(_data["saleManager"])
        : <any>null;
      this.invoiceThresholdDay =
        _data["invoiceThresholdDay"] !== undefined
          ? _data["invoiceThresholdDay"]
          : <any>null;
    }
  }

  static fromJS(data: any): MerchantLight {
    data = typeof data === "object" ? data : {};
    let result = new MerchantLight();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["merchantName"] =
      this.merchantName !== undefined ? this.merchantName : <any>null;
    data["parentBranchId"] =
      this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
    data["rootBranchId"] =
      this.rootBranchId !== undefined ? this.rootBranchId : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
    data["creditWalletId"] =
      this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
    data["externalReference"] =
      this.externalReference !== undefined ? this.externalReference : <any>null;
    data["exchangeTargetCurrency"] = this.exchangeTargetCurrency
      ? this.exchangeTargetCurrency.toJSON()
      : <any>null;
    data["saleManager"] = this.saleManager
      ? this.saleManager.toJSON()
      : <any>null;
    data["invoiceThresholdDay"] =
      this.invoiceThresholdDay !== undefined
        ? this.invoiceThresholdDay
        : <any>null;
    return data;
  }
}

export interface IMerchantLight {
  merchantId: number;
  merchantName: string;
  parentBranchId?: number | null;
  rootBranchId?: number | null;
  description?: string | null;
  isActive: boolean;
  email: string;
  walletId: number;
  creditWalletId?: number | null;
  externalReference: string;
  exchangeTargetCurrency: Currency;
  saleManager?: SaleManagerSummary | null;
  invoiceThresholdDay?: number | null;
}

export class Currency implements ICurrency {
  currencyId!: number;
  currencyName!: string;
  isForTest?: boolean | null;

  constructor(data?: ICurrency) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.currencyName =
        _data["currencyName"] !== undefined ? _data["currencyName"] : <any>null;
      this.isForTest =
        _data["isForTest"] !== undefined ? _data["isForTest"] : <any>null;
    }
  }

  static fromJS(data: any): Currency {
    data = typeof data === "object" ? data : {};
    let result = new Currency();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["currencyName"] =
      this.currencyName !== undefined ? this.currencyName : <any>null;
    data["isForTest"] =
      this.isForTest !== undefined ? this.isForTest : <any>null;
    return data;
  }
}

export interface ICurrency {
  currencyId: number;
  currencyName: string;
  isForTest?: boolean | null;
}

export class SaleManagerSummary implements ISaleManagerSummary {
  saleManagerId!: number;
  name?: string | null;

  constructor(data?: ISaleManagerSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.saleManagerId =
        _data["saleManagerId"] !== undefined
          ? _data["saleManagerId"]
          : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
    }
  }

  static fromJS(data: any): SaleManagerSummary {
    data = typeof data === "object" ? data : {};
    let result = new SaleManagerSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["saleManagerId"] =
      this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    return data;
  }
}

export interface ISaleManagerSummary {
  saleManagerId: number;
  name?: string | null;
}

export class Branch implements IBranch {
  branchId!: number;
  branchName!: string;
  merchantId!: number;
  merchantName!: string;
  parentBranchId?: number | null;
  description?: string | null;
  isActive!: boolean;
  rootPriceListId?: number | null;
  canSetFaceValue!: boolean;
  canSetBuyValue!: boolean;
  canCreatePaymentOrder!: boolean;
  canPlaceOrder!: boolean;
  canCreateGatewayList!: boolean;
  middlePriceList?: PriceListSummary | null;
  assignedPriceList?: PriceListSummary | null;
  merchant?: Merchant | null;

  constructor(data?: IBranch) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.branchName =
        _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.merchantName =
        _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
      this.parentBranchId =
        _data["parentBranchId"] !== undefined
          ? _data["parentBranchId"]
          : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.rootPriceListId =
        _data["rootPriceListId"] !== undefined
          ? _data["rootPriceListId"]
          : <any>null;
      this.canSetFaceValue =
        _data["canSetFaceValue"] !== undefined
          ? _data["canSetFaceValue"]
          : <any>null;
      this.canSetBuyValue =
        _data["canSetBuyValue"] !== undefined
          ? _data["canSetBuyValue"]
          : <any>null;
      this.canCreatePaymentOrder =
        _data["canCreatePaymentOrder"] !== undefined
          ? _data["canCreatePaymentOrder"]
          : <any>null;
      this.canPlaceOrder =
        _data["canPlaceOrder"] !== undefined
          ? _data["canPlaceOrder"]
          : <any>null;
      this.canCreateGatewayList =
        _data["canCreateGatewayList"] !== undefined
          ? _data["canCreateGatewayList"]
          : <any>null;
      this.middlePriceList = _data["middlePriceList"]
        ? PriceListSummary.fromJS(_data["middlePriceList"])
        : <any>null;
      this.assignedPriceList = _data["assignedPriceList"]
        ? PriceListSummary.fromJS(_data["assignedPriceList"])
        : <any>null;
      this.merchant = _data["merchant"]
        ? Merchant.fromJS(_data["merchant"])
        : <any>null;
    }
  }

  static fromJS(data: any): Branch {
    data = typeof data === "object" ? data : {};
    let result = new Branch();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["branchName"] =
      this.branchName !== undefined ? this.branchName : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["merchantName"] =
      this.merchantName !== undefined ? this.merchantName : <any>null;
    data["parentBranchId"] =
      this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["rootPriceListId"] =
      this.rootPriceListId !== undefined ? this.rootPriceListId : <any>null;
    data["canSetFaceValue"] =
      this.canSetFaceValue !== undefined ? this.canSetFaceValue : <any>null;
    data["canSetBuyValue"] =
      this.canSetBuyValue !== undefined ? this.canSetBuyValue : <any>null;
    data["canCreatePaymentOrder"] =
      this.canCreatePaymentOrder !== undefined
        ? this.canCreatePaymentOrder
        : <any>null;
    data["canPlaceOrder"] =
      this.canPlaceOrder !== undefined ? this.canPlaceOrder : <any>null;
    data["canCreateGatewayList"] =
      this.canCreateGatewayList !== undefined
        ? this.canCreateGatewayList
        : <any>null;
    data["middlePriceList"] = this.middlePriceList
      ? this.middlePriceList.toJSON()
      : <any>null;
    data["assignedPriceList"] = this.assignedPriceList
      ? this.assignedPriceList.toJSON()
      : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    return data;
  }
}

export interface IBranch {
  branchId: number;
  branchName: string;
  merchantId: number;
  merchantName: string;
  parentBranchId?: number | null;
  description?: string | null;
  isActive: boolean;
  rootPriceListId?: number | null;
  canSetFaceValue: boolean;
  canSetBuyValue: boolean;
  canCreatePaymentOrder: boolean;
  canPlaceOrder: boolean;
  canCreateGatewayList: boolean;
  middlePriceList?: PriceListSummary | null;
  assignedPriceList?: PriceListSummary | null;
  merchant?: Merchant | null;
}

export class Merchant implements IMerchant {
  merchantId!: number;
  merchantName!: string;
  parentBranchId?: number | null;
  rootBranchId!: number;
  description?: string | null;
  isActive!: boolean;
  email!: string;
  phoneNumber?: Phone | null;
  whatsappNumber?: Phone | null;
  address?: MerchantAddress | null;
  website?: string | null;
  walletId!: number;
  financialActivitiesTwoPhaseVerification!: boolean;
  creditWalletId?: number | null;
  assignedGatewayListId?: number | null;
  externalReference!: string;
  exchangeTargetCurrency!: Currency;
  saleManager?: SaleManagerSummary | null;
  gatewayListSummary?: GatewayListSummary[] | null;
  invoiceThresholdDay?: number | null;
  timeZone?: string | null;

  constructor(data?: IMerchant) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.exchangeTargetCurrency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.merchantName =
        _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
      this.parentBranchId =
        _data["parentBranchId"] !== undefined
          ? _data["parentBranchId"]
          : <any>null;
      this.rootBranchId =
        _data["rootBranchId"] !== undefined ? _data["rootBranchId"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.phoneNumber = _data["phoneNumber"]
        ? Phone.fromJS(_data["phoneNumber"])
        : <any>null;
      this.whatsappNumber = _data["whatsappNumber"]
        ? Phone.fromJS(_data["whatsappNumber"])
        : <any>null;
      this.address = _data["address"]
        ? MerchantAddress.fromJS(_data["address"])
        : <any>null;
      this.website =
        _data["website"] !== undefined ? _data["website"] : <any>null;
      this.walletId =
        _data["walletId"] !== undefined ? _data["walletId"] : <any>null;
      this.financialActivitiesTwoPhaseVerification =
        _data["financialActivitiesTwoPhaseVerification"] !== undefined
          ? _data["financialActivitiesTwoPhaseVerification"]
          : <any>null;
      this.creditWalletId =
        _data["creditWalletId"] !== undefined
          ? _data["creditWalletId"]
          : <any>null;
      this.assignedGatewayListId =
        _data["assignedGatewayListId"] !== undefined
          ? _data["assignedGatewayListId"]
          : <any>null;
      this.externalReference =
        _data["externalReference"] !== undefined
          ? _data["externalReference"]
          : <any>null;
      this.exchangeTargetCurrency = _data["exchangeTargetCurrency"]
        ? Currency.fromJS(_data["exchangeTargetCurrency"])
        : new Currency();
      this.saleManager = _data["saleManager"]
        ? SaleManagerSummary.fromJS(_data["saleManager"])
        : <any>null;
      if (Array.isArray(_data["gatewayListSummary"])) {
        this.gatewayListSummary = [] as any;
        for (let item of _data["gatewayListSummary"])
          this.gatewayListSummary!.push(GatewayListSummary.fromJS(item));
      } else {
        this.gatewayListSummary = <any>null;
      }
      this.invoiceThresholdDay =
        _data["invoiceThresholdDay"] !== undefined
          ? _data["invoiceThresholdDay"]
          : <any>null;
      this.timeZone =
        _data["timeZone"] !== undefined ? _data["timeZone"] : <any>null;
    }
  }

  static fromJS(data: any): Merchant {
    data = typeof data === "object" ? data : {};
    let result = new Merchant();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["merchantName"] =
      this.merchantName !== undefined ? this.merchantName : <any>null;
    data["parentBranchId"] =
      this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
    data["rootBranchId"] =
      this.rootBranchId !== undefined ? this.rootBranchId : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["phoneNumber"] = this.phoneNumber
      ? this.phoneNumber.toJSON()
      : <any>null;
    data["whatsappNumber"] = this.whatsappNumber
      ? this.whatsappNumber.toJSON()
      : <any>null;
    data["address"] = this.address ? this.address.toJSON() : <any>null;
    data["website"] = this.website !== undefined ? this.website : <any>null;
    data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
    data["financialActivitiesTwoPhaseVerification"] =
      this.financialActivitiesTwoPhaseVerification !== undefined
        ? this.financialActivitiesTwoPhaseVerification
        : <any>null;
    data["creditWalletId"] =
      this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
    data["assignedGatewayListId"] =
      this.assignedGatewayListId !== undefined
        ? this.assignedGatewayListId
        : <any>null;
    data["externalReference"] =
      this.externalReference !== undefined ? this.externalReference : <any>null;
    data["exchangeTargetCurrency"] = this.exchangeTargetCurrency
      ? this.exchangeTargetCurrency.toJSON()
      : <any>null;
    data["saleManager"] = this.saleManager
      ? this.saleManager.toJSON()
      : <any>null;
    if (Array.isArray(this.gatewayListSummary)) {
      data["gatewayListSummary"] = [];
      for (let item of this.gatewayListSummary)
        data["gatewayListSummary"].push(item.toJSON());
    }
    data["invoiceThresholdDay"] =
      this.invoiceThresholdDay !== undefined
        ? this.invoiceThresholdDay
        : <any>null;
    data["timeZone"] = this.timeZone !== undefined ? this.timeZone : <any>null;
    return data;
  }
}

export interface IMerchant {
  merchantId: number;
  merchantName: string;
  parentBranchId?: number | null;
  rootBranchId: number;
  description?: string | null;
  isActive: boolean;
  email: string;
  phoneNumber?: Phone | null;
  whatsappNumber?: Phone | null;
  address?: MerchantAddress | null;
  website?: string | null;
  walletId: number;
  financialActivitiesTwoPhaseVerification: boolean;
  creditWalletId?: number | null;
  assignedGatewayListId?: number | null;
  externalReference: string;
  exchangeTargetCurrency: Currency;
  saleManager?: SaleManagerSummary | null;
  gatewayListSummary?: GatewayListSummary[] | null;
  invoiceThresholdDay?: number | null;
  timeZone?: string | null;
}

export class Phone implements IPhone {
  countryCode!: string;
  number!: string;

  constructor(data?: IPhone) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryCode =
        _data["countryCode"] !== undefined ? _data["countryCode"] : <any>null;
      this.number = _data["number"] !== undefined ? _data["number"] : <any>null;
    }
  }

  static fromJS(data: any): Phone {
    data = typeof data === "object" ? data : {};
    let result = new Phone();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["countryCode"] =
      this.countryCode !== undefined ? this.countryCode : <any>null;
    data["number"] = this.number !== undefined ? this.number : <any>null;
    return data;
  }
}

export interface IPhone {
  countryCode: string;
  number: string;
}

export class MerchantAddress implements IMerchantAddress {
  country?: string | null;
  state?: string | null;
  city?: string | null;
  rawAddress?: string | null;
  postalCode?: string | null;

  constructor(data?: IMerchantAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.country =
        _data["country"] !== undefined ? _data["country"] : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
      this.rawAddress =
        _data["rawAddress"] !== undefined ? _data["rawAddress"] : <any>null;
      this.postalCode =
        _data["postalCode"] !== undefined ? _data["postalCode"] : <any>null;
    }
  }

  static fromJS(data: any): MerchantAddress {
    data = typeof data === "object" ? data : {};
    let result = new MerchantAddress();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["country"] = this.country !== undefined ? this.country : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["city"] = this.city !== undefined ? this.city : <any>null;
    data["rawAddress"] =
      this.rawAddress !== undefined ? this.rawAddress : <any>null;
    data["postalCode"] =
      this.postalCode !== undefined ? this.postalCode : <any>null;
    return data;
  }
}

export interface IMerchantAddress {
  country?: string | null;
  state?: string | null;
  city?: string | null;
  rawAddress?: string | null;
  postalCode?: string | null;
}

export class GatewayListSummary implements IGatewayListSummary {
  gatewayListId!: number;
  gatewayListName!: string;

  constructor(data?: IGatewayListSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.gatewayListId =
        _data["gatewayListId"] !== undefined
          ? _data["gatewayListId"]
          : <any>null;
      this.gatewayListName =
        _data["gatewayListName"] !== undefined
          ? _data["gatewayListName"]
          : <any>null;
    }
  }

  static fromJS(data: any): GatewayListSummary {
    data = typeof data === "object" ? data : {};
    let result = new GatewayListSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["gatewayListId"] =
      this.gatewayListId !== undefined ? this.gatewayListId : <any>null;
    data["gatewayListName"] =
      this.gatewayListName !== undefined ? this.gatewayListName : <any>null;
    return data;
  }
}

export interface IGatewayListSummary {
  gatewayListId: number;
  gatewayListName: string;
}

export class BuyOrder implements IBuyOrder {
  buyOrderId!: number;
  buyOrderExternalId!: string;
  productId!: number;
  productName!: string;
  isPhysicalProduct!: boolean;
  quantity!: number;
  faceValue!: number;
  buyOrderState!: BuyOrderState;
  sellerMerchant!: MerchantSummary;
  buyerMerchant!: MerchantSummary;
  buyOrderDelivery?: BuyOrderDelivery | null;
  saleManager?: SaleManagerSummary | null;
  totalBuyAmount!: number;
  unitBuyAmount!: number;
  profit?: number | null;
  productCurrency!: Currency;
  buyCurrency!: Currency;
  createdTime!: Date;
  canDownloadCodes!: boolean;
  exchangeCalc?: ExchangeCalc | null;

  constructor(data?: IBuyOrder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.sellerMerchant = new MerchantSummary();
      this.buyerMerchant = new MerchantSummary();
      this.productCurrency = new Currency();
      this.buyCurrency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.buyOrderId =
        _data["buyOrderId"] !== undefined ? _data["buyOrderId"] : <any>null;
      this.buyOrderExternalId =
        _data["buyOrderExternalId"] !== undefined
          ? _data["buyOrderExternalId"]
          : <any>null;
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.isPhysicalProduct =
        _data["isPhysicalProduct"] !== undefined
          ? _data["isPhysicalProduct"]
          : <any>null;
      this.quantity =
        _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
      this.faceValue =
        _data["faceValue"] !== undefined ? _data["faceValue"] : <any>null;
      this.buyOrderState =
        _data["buyOrderState"] !== undefined
          ? _data["buyOrderState"]
          : <any>null;
      this.sellerMerchant = _data["sellerMerchant"]
        ? MerchantSummary.fromJS(_data["sellerMerchant"])
        : new MerchantSummary();
      this.buyerMerchant = _data["buyerMerchant"]
        ? MerchantSummary.fromJS(_data["buyerMerchant"])
        : new MerchantSummary();
      this.buyOrderDelivery = _data["buyOrderDelivery"]
        ? BuyOrderDelivery.fromJS(_data["buyOrderDelivery"])
        : <any>null;
      this.saleManager = _data["saleManager"]
        ? SaleManagerSummary.fromJS(_data["saleManager"])
        : <any>null;
      this.totalBuyAmount =
        _data["totalBuyAmount"] !== undefined
          ? _data["totalBuyAmount"]
          : <any>null;
      this.unitBuyAmount =
        _data["unitBuyAmount"] !== undefined
          ? _data["unitBuyAmount"]
          : <any>null;
      this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
      this.productCurrency = _data["productCurrency"]
        ? Currency.fromJS(_data["productCurrency"])
        : new Currency();
      this.buyCurrency = _data["buyCurrency"]
        ? Currency.fromJS(_data["buyCurrency"])
        : new Currency();
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.canDownloadCodes =
        _data["canDownloadCodes"] !== undefined
          ? _data["canDownloadCodes"]
          : <any>null;
      this.exchangeCalc = _data["exchangeCalc"]
        ? ExchangeCalc.fromJS(_data["exchangeCalc"])
        : <any>null;
    }
  }

  static fromJS(data: any): BuyOrder {
    data = typeof data === "object" ? data : {};
    let result = new BuyOrder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["buyOrderId"] =
      this.buyOrderId !== undefined ? this.buyOrderId : <any>null;
    data["buyOrderExternalId"] =
      this.buyOrderExternalId !== undefined
        ? this.buyOrderExternalId
        : <any>null;
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    data["isPhysicalProduct"] =
      this.isPhysicalProduct !== undefined ? this.isPhysicalProduct : <any>null;
    data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
    data["faceValue"] =
      this.faceValue !== undefined ? this.faceValue : <any>null;
    data["buyOrderState"] =
      this.buyOrderState !== undefined ? this.buyOrderState : <any>null;
    data["sellerMerchant"] = this.sellerMerchant
      ? this.sellerMerchant.toJSON()
      : <any>null;
    data["buyerMerchant"] = this.buyerMerchant
      ? this.buyerMerchant.toJSON()
      : <any>null;
    data["buyOrderDelivery"] = this.buyOrderDelivery
      ? this.buyOrderDelivery.toJSON()
      : <any>null;
    data["saleManager"] = this.saleManager
      ? this.saleManager.toJSON()
      : <any>null;
    data["totalBuyAmount"] =
      this.totalBuyAmount !== undefined ? this.totalBuyAmount : <any>null;
    data["unitBuyAmount"] =
      this.unitBuyAmount !== undefined ? this.unitBuyAmount : <any>null;
    data["profit"] = this.profit !== undefined ? this.profit : <any>null;
    data["productCurrency"] = this.productCurrency
      ? this.productCurrency.toJSON()
      : <any>null;
    data["buyCurrency"] = this.buyCurrency
      ? this.buyCurrency.toJSON()
      : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["canDownloadCodes"] =
      this.canDownloadCodes !== undefined ? this.canDownloadCodes : <any>null;
    data["exchangeCalc"] = this.exchangeCalc
      ? this.exchangeCalc.toJSON()
      : <any>null;
    return data;
  }
}

export interface IBuyOrder {
  buyOrderId: number;
  buyOrderExternalId: string;
  productId: number;
  productName: string;
  isPhysicalProduct: boolean;
  quantity: number;
  faceValue: number;
  buyOrderState: BuyOrderState;
  sellerMerchant: MerchantSummary;
  buyerMerchant: MerchantSummary;
  buyOrderDelivery?: BuyOrderDelivery | null;
  saleManager?: SaleManagerSummary | null;
  totalBuyAmount: number;
  unitBuyAmount: number;
  profit?: number | null;
  productCurrency: Currency;
  buyCurrency: Currency;
  createdTime: Date;
  canDownloadCodes: boolean;
  exchangeCalc?: ExchangeCalc | null;
}

export enum BuyOrderState {
  Reserved = "Reserved",
  Created = "Created",
  CreateStockOrder = "CreateStockOrder",
  AuthWallet = "AuthWallet",
  Failed = "Failed",
  Complete = "Complete",
  CancelAuthWallet = "CancelAuthWallet",
  CompleteStockOrder = "CompleteStockOrder",
  CreateActivatePhysicalCardOrder = "CreateActivatePhysicalCardOrder",
  CompleteActivatePhysicalCardOrder = "CompleteActivatePhysicalCardOrder",
}

export class MerchantSummary implements IMerchantSummary {
  merchantId!: number;
  merchantName!: string;
  saleManager?: SaleManagerSummary | null;

  constructor(data?: IMerchantSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.merchantName =
        _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
      this.saleManager = _data["saleManager"]
        ? SaleManagerSummary.fromJS(_data["saleManager"])
        : <any>null;
    }
  }

  static fromJS(data: any): MerchantSummary {
    data = typeof data === "object" ? data : {};
    let result = new MerchantSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["merchantName"] =
      this.merchantName !== undefined ? this.merchantName : <any>null;
    data["saleManager"] = this.saleManager
      ? this.saleManager.toJSON()
      : <any>null;
    return data;
  }
}

export interface IMerchantSummary {
  merchantId: number;
  merchantName: string;
  saleManager?: SaleManagerSummary | null;
}

export class BuyOrderDelivery implements IBuyOrderDelivery {
  deliveryType!: BuyOrderDeliveryType;
  deliveryTypeValue?: string | null;
  deliveredTime?: Date | null;

  constructor(data?: IBuyOrderDelivery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.deliveryType =
        _data["deliveryType"] !== undefined ? _data["deliveryType"] : <any>null;
      this.deliveryTypeValue =
        _data["deliveryTypeValue"] !== undefined
          ? _data["deliveryTypeValue"]
          : <any>null;
      this.deliveredTime = _data["deliveredTime"]
        ? new Date(_data["deliveredTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): BuyOrderDelivery {
    data = typeof data === "object" ? data : {};
    let result = new BuyOrderDelivery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["deliveryType"] =
      this.deliveryType !== undefined ? this.deliveryType : <any>null;
    data["deliveryTypeValue"] =
      this.deliveryTypeValue !== undefined ? this.deliveryTypeValue : <any>null;
    data["deliveredTime"] = this.deliveredTime
      ? this.deliveredTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IBuyOrderDelivery {
  deliveryType: BuyOrderDeliveryType;
  deliveryTypeValue?: string | null;
  deliveredTime?: Date | null;
}

export enum BuyOrderDeliveryType {
  Email = "Email",
  Sms = "Sms",
  WhatsApp = "WhatsApp",
}

export class ExchangeCalc implements IExchangeCalc {
  baseCurrency!: Currency;
  baseAmount!: number;
  targetCurrency!: Currency;
  targetAmount!: number;
  exchangeRate!: number;

  constructor(data?: IExchangeCalc) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.baseCurrency = new Currency();
      this.targetCurrency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.baseCurrency = _data["baseCurrency"]
        ? Currency.fromJS(_data["baseCurrency"])
        : new Currency();
      this.baseAmount =
        _data["baseAmount"] !== undefined ? _data["baseAmount"] : <any>null;
      this.targetCurrency = _data["targetCurrency"]
        ? Currency.fromJS(_data["targetCurrency"])
        : new Currency();
      this.targetAmount =
        _data["targetAmount"] !== undefined ? _data["targetAmount"] : <any>null;
      this.exchangeRate =
        _data["exchangeRate"] !== undefined ? _data["exchangeRate"] : <any>null;
    }
  }

  static fromJS(data: any): ExchangeCalc {
    data = typeof data === "object" ? data : {};
    let result = new ExchangeCalc();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["baseCurrency"] = this.baseCurrency
      ? this.baseCurrency.toJSON()
      : <any>null;
    data["baseAmount"] =
      this.baseAmount !== undefined ? this.baseAmount : <any>null;
    data["targetCurrency"] = this.targetCurrency
      ? this.targetCurrency.toJSON()
      : <any>null;
    data["targetAmount"] =
      this.targetAmount !== undefined ? this.targetAmount : <any>null;
    data["exchangeRate"] =
      this.exchangeRate !== undefined ? this.exchangeRate : <any>null;
    return data;
  }
}

export interface IExchangeCalc {
  baseCurrency: Currency;
  baseAmount: number;
  targetCurrency: Currency;
  targetAmount: number;
  exchangeRate: number;
}

export class SaleBranches implements ISaleBranches {
  branchId!: number;
  currencyId!: number;
  currencyName!: string;
  branchName!: string;
  saleAmount!: number;

  constructor(data?: ISaleBranches) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.currencyName =
        _data["currencyName"] !== undefined ? _data["currencyName"] : <any>null;
      this.branchName =
        _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
      this.saleAmount =
        _data["saleAmount"] !== undefined ? _data["saleAmount"] : <any>null;
    }
  }

  static fromJS(data: any): SaleBranches {
    data = typeof data === "object" ? data : {};
    let result = new SaleBranches();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["currencyName"] =
      this.currencyName !== undefined ? this.currencyName : <any>null;
    data["branchName"] =
      this.branchName !== undefined ? this.branchName : <any>null;
    data["saleAmount"] =
      this.saleAmount !== undefined ? this.saleAmount : <any>null;
    return data;
  }
}

export interface ISaleBranches {
  branchId: number;
  currencyId: number;
  currencyName: string;
  branchName: string;
  saleAmount: number;
}

export class SaleReturnOrder implements ISaleReturnOrder {
  rollBackOrderId!: number;
  buyOrder?: BuyOrderSummary | null;
  state!: SaleReturnOrderState;
  createdTime!: Date;
  modifiedTime!: Date;

  constructor(data?: ISaleReturnOrder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.rollBackOrderId =
        _data["rollBackOrderId"] !== undefined
          ? _data["rollBackOrderId"]
          : <any>null;
      this.buyOrder = _data["buyOrder"]
        ? BuyOrderSummary.fromJS(_data["buyOrder"])
        : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): SaleReturnOrder {
    data = typeof data === "object" ? data : {};
    let result = new SaleReturnOrder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["rollBackOrderId"] =
      this.rollBackOrderId !== undefined ? this.rollBackOrderId : <any>null;
    data["buyOrder"] = this.buyOrder ? this.buyOrder.toJSON() : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface ISaleReturnOrder {
  rollBackOrderId: number;
  buyOrder?: BuyOrderSummary | null;
  state: SaleReturnOrderState;
  createdTime: Date;
  modifiedTime: Date;
}

export class BuyOrderSummary implements IBuyOrderSummary {
  buyOrderId!: number;
  merchantId!: number;
  buyOrderExternalId!: string;
  buyOrderState!: BuyOrderState;

  constructor(data?: IBuyOrderSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.buyOrderId =
        _data["buyOrderId"] !== undefined ? _data["buyOrderId"] : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.buyOrderExternalId =
        _data["buyOrderExternalId"] !== undefined
          ? _data["buyOrderExternalId"]
          : <any>null;
      this.buyOrderState =
        _data["buyOrderState"] !== undefined
          ? _data["buyOrderState"]
          : <any>null;
    }
  }

  static fromJS(data: any): BuyOrderSummary {
    data = typeof data === "object" ? data : {};
    let result = new BuyOrderSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["buyOrderId"] =
      this.buyOrderId !== undefined ? this.buyOrderId : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["buyOrderExternalId"] =
      this.buyOrderExternalId !== undefined
        ? this.buyOrderExternalId
        : <any>null;
    data["buyOrderState"] =
      this.buyOrderState !== undefined ? this.buyOrderState : <any>null;
    return data;
  }
}

export interface IBuyOrderSummary {
  buyOrderId: number;
  merchantId: number;
  buyOrderExternalId: string;
  buyOrderState: BuyOrderState;
}

export enum SaleReturnOrderState {
  Reserved = "Reserved",
  Created = "Created",
  CancelStockOrder = "CancelStockOrder",
  CompleteCancelStockOrder = "CompleteCancelStockOrder",
  VoidWallet = "VoidWallet",
  Failed = "Failed",
}

export class Category implements ICategory {
  categoryId!: number;
  categoryName!: string;
  imageUrl?: string | null;
  parentCategoryId?: number | null;
  categories!: Category[];

  constructor(data?: ICategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.categories = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryId =
        _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
      this.categoryName =
        _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.parentCategoryId =
        _data["parentCategoryId"] !== undefined
          ? _data["parentCategoryId"]
          : <any>null;
      if (Array.isArray(_data["categories"])) {
        this.categories = [] as any;
        for (let item of _data["categories"])
          this.categories!.push(Category.fromJS(item));
      } else {
        this.categories = <any>null;
      }
    }
  }

  static fromJS(data: any): Category {
    data = typeof data === "object" ? data : {};
    let result = new Category();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["categoryId"] =
      this.categoryId !== undefined ? this.categoryId : <any>null;
    data["categoryName"] =
      this.categoryName !== undefined ? this.categoryName : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["parentCategoryId"] =
      this.parentCategoryId !== undefined ? this.parentCategoryId : <any>null;
    if (Array.isArray(this.categories)) {
      data["categories"] = [];
      for (let item of this.categories) data["categories"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICategory {
  categoryId: number;
  categoryName: string;
  imageUrl?: string | null;
  parentCategoryId?: number | null;
  categories: Category[];
}

export class CreateCategoryRequest implements ICreateCategoryRequest {
  parentCategoryId!: number;
  categoryName!: string;
  imageUrl?: string | null;

  constructor(data?: ICreateCategoryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parentCategoryId =
        _data["parentCategoryId"] !== undefined
          ? _data["parentCategoryId"]
          : <any>null;
      this.categoryName =
        _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
    }
  }

  static fromJS(data: any): CreateCategoryRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateCategoryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["parentCategoryId"] =
      this.parentCategoryId !== undefined ? this.parentCategoryId : <any>null;
    data["categoryName"] =
      this.categoryName !== undefined ? this.categoryName : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    return data;
  }
}

export interface ICreateCategoryRequest {
  parentCategoryId: number;
  categoryName: string;
  imageUrl?: string | null;
}

export class UpdateCategoryRequest implements IUpdateCategoryRequest {
  categoryName?: PatchOfString | null;
  imageUrl?: PatchOfUri | null;

  constructor(data?: IUpdateCategoryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryName = _data["categoryName"]
        ? PatchOfString.fromJS(_data["categoryName"])
        : <any>null;
      this.imageUrl = _data["imageUrl"]
        ? PatchOfUri.fromJS(_data["imageUrl"])
        : <any>null;
    }
  }

  static fromJS(data: any): UpdateCategoryRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateCategoryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["categoryName"] = this.categoryName
      ? this.categoryName.toJSON()
      : <any>null;
    data["imageUrl"] = this.imageUrl ? this.imageUrl.toJSON() : <any>null;
    return data;
  }
}

export interface IUpdateCategoryRequest {
  categoryName?: PatchOfString | null;
  imageUrl?: PatchOfUri | null;
}

export class PatchOfString implements IPatchOfString {
  value?: string | null;

  constructor(data?: IPatchOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
    }
  }

  static fromJS(data: any): PatchOfString {
    data = typeof data === "object" ? data : {};
    let result = new PatchOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value !== undefined ? this.value : <any>null;
    return data;
  }
}

export interface IPatchOfString {
  value?: string | null;
}

export class PatchOfUri implements IPatchOfUri {
  value?: string | null;

  constructor(data?: IPatchOfUri) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
    }
  }

  static fromJS(data: any): PatchOfUri {
    data = typeof data === "object" ? data : {};
    let result = new PatchOfUri();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value !== undefined ? this.value : <any>null;
    return data;
  }
}

export interface IPatchOfUri {
  value?: string | null;
}

export class Wallet implements IWallet {
  walletId!: number;
  currencies?: CurrencyBalance[] | null;

  constructor(data?: IWallet) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.walletId =
        _data["walletId"] !== undefined ? _data["walletId"] : <any>null;
      if (Array.isArray(_data["currencies"])) {
        this.currencies = [] as any;
        for (let item of _data["currencies"])
          this.currencies!.push(CurrencyBalance.fromJS(item));
      } else {
        this.currencies = <any>null;
      }
    }
  }

  static fromJS(data: any): Wallet {
    data = typeof data === "object" ? data : {};
    let result = new Wallet();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
    if (Array.isArray(this.currencies)) {
      data["currencies"] = [];
      for (let item of this.currencies) data["currencies"].push(item.toJSON());
    }
    return data;
  }
}

export interface IWallet {
  walletId: number;
  currencies?: CurrencyBalance[] | null;
}

export class CurrencyBalance implements ICurrencyBalance {
  balance!: number;
  minBalance!: number;
  currency!: Currency;

  constructor(data?: ICurrencyBalance) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.balance =
        _data["balance"] !== undefined ? _data["balance"] : <any>null;
      this.minBalance =
        _data["minBalance"] !== undefined ? _data["minBalance"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
    }
  }

  static fromJS(data: any): CurrencyBalance {
    data = typeof data === "object" ? data : {};
    let result = new CurrencyBalance();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["balance"] = this.balance !== undefined ? this.balance : <any>null;
    data["minBalance"] =
      this.minBalance !== undefined ? this.minBalance : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    return data;
  }
}

export interface ICurrencyBalance {
  balance: number;
  minBalance: number;
  currency: Currency;
}

export class WalletTransaction implements IWalletTransaction {
  supplierMerchant!: MerchantSummary;
  receiverMerchant!: MerchantSummary;
  amount!: number;
  currency!: Currency;
  bank?: Bank | null;
  createdTime!: Date;
  transferWalletType!: TransferWalletType;
  transferWalletState!: TransferWalletState;

  constructor(data?: IWalletTransaction) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.supplierMerchant = new MerchantSummary();
      this.receiverMerchant = new MerchantSummary();
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.supplierMerchant = _data["supplierMerchant"]
        ? MerchantSummary.fromJS(_data["supplierMerchant"])
        : new MerchantSummary();
      this.receiverMerchant = _data["receiverMerchant"]
        ? MerchantSummary.fromJS(_data["receiverMerchant"])
        : new MerchantSummary();
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      this.bank = _data["bank"] ? Bank.fromJS(_data["bank"]) : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.transferWalletType =
        _data["transferWalletType"] !== undefined
          ? _data["transferWalletType"]
          : <any>null;
      this.transferWalletState =
        _data["transferWalletState"] !== undefined
          ? _data["transferWalletState"]
          : <any>null;
    }
  }

  static fromJS(data: any): WalletTransaction {
    data = typeof data === "object" ? data : {};
    let result = new WalletTransaction();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["supplierMerchant"] = this.supplierMerchant
      ? this.supplierMerchant.toJSON()
      : <any>null;
    data["receiverMerchant"] = this.receiverMerchant
      ? this.receiverMerchant.toJSON()
      : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["bank"] = this.bank ? this.bank.toJSON() : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["transferWalletType"] =
      this.transferWalletType !== undefined
        ? this.transferWalletType
        : <any>null;
    data["transferWalletState"] =
      this.transferWalletState !== undefined
        ? this.transferWalletState
        : <any>null;
    return data;
  }
}

export interface IWalletTransaction {
  supplierMerchant: MerchantSummary;
  receiverMerchant: MerchantSummary;
  amount: number;
  currency: Currency;
  bank?: Bank | null;
  createdTime: Date;
  transferWalletType: TransferWalletType;
  transferWalletState: TransferWalletState;
}

export enum TransferWalletType {
  Charge = "Charge",
  Buy = "Buy",
  Credit = "Credit",
  Payment = "Payment",
  Settle = "Settle",
  Withdraw = "Withdraw",
  Rebate = "Rebate",
  SaleReturn = "SaleReturn",
}

export enum TransferWalletState {
  Reserved = "Reserved",
  Pending = "Pending",
  Failed = "Failed",
  Completed = "Completed",
  Unverified = "Unverified",
  Created = "Created",
  Rejecting = "Rejecting",
}

export enum CreditTransactionType {
  Credit = "Credit",
  Settle = "Settle",
}

export class PutCurrencyExchangeRateRequest
  implements IPutCurrencyExchangeRateRequest
{
  baseCurrencyId!: number;
  targetCurrencyId!: number;
  exchangeRateFee!: number;

  constructor(data?: IPutCurrencyExchangeRateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.baseCurrencyId =
        _data["baseCurrencyId"] !== undefined
          ? _data["baseCurrencyId"]
          : <any>null;
      this.targetCurrencyId =
        _data["targetCurrencyId"] !== undefined
          ? _data["targetCurrencyId"]
          : <any>null;
      this.exchangeRateFee =
        _data["exchangeRateFee"] !== undefined
          ? _data["exchangeRateFee"]
          : <any>null;
    }
  }

  static fromJS(data: any): PutCurrencyExchangeRateRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutCurrencyExchangeRateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["baseCurrencyId"] =
      this.baseCurrencyId !== undefined ? this.baseCurrencyId : <any>null;
    data["targetCurrencyId"] =
      this.targetCurrencyId !== undefined ? this.targetCurrencyId : <any>null;
    data["exchangeRateFee"] =
      this.exchangeRateFee !== undefined ? this.exchangeRateFee : <any>null;
    return data;
  }
}

export interface IPutCurrencyExchangeRateRequest {
  baseCurrencyId: number;
  targetCurrencyId: number;
  exchangeRateFee: number;
}

export enum FinancialOrderType {
  Charge = "Charge",
  Withdraw = "Withdraw",
  Credit = "Credit",
  Settle = "Settle",
  Rebate = "Rebate",
}

export class FinancialRequest implements IFinancialRequest {
  customerMerchantId!: number;
  currencyId!: number;
  amount!: number;
  description!: string;
  bankId?: number | null;

  constructor(data?: IFinancialRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.customerMerchantId =
        _data["customerMerchantId"] !== undefined
          ? _data["customerMerchantId"]
          : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.bankId = _data["bankId"] !== undefined ? _data["bankId"] : <any>null;
    }
  }

  static fromJS(data: any): FinancialRequest {
    data = typeof data === "object" ? data : {};
    let result = new FinancialRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["customerMerchantId"] =
      this.customerMerchantId !== undefined
        ? this.customerMerchantId
        : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["bankId"] = this.bankId !== undefined ? this.bankId : <any>null;
    return data;
  }
}

export interface IFinancialRequest {
  customerMerchantId: number;
  currencyId: number;
  amount: number;
  description: string;
  bankId?: number | null;
}

export class FinancialOrder implements IFinancialOrder {
  orderId!: number;
  amount!: number;
  currency!: Currency;
  financialOrderType!: FinancialOrderType;
  financialOrderState!: FinancialOrderState;
  firstVerifierUserId?: string | null;
  firstVerifierUserEmail?: string | null;
  secondVerifierUserId?: string | null;
  secondVerifierUserEmail?: string | null;
  createdTime!: Date;
  baseMerchant!: MerchantSummary;
  targetMerchant!: MerchantSummary;
  description?: string | null;

  constructor(data?: IFinancialOrder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
      this.baseMerchant = new MerchantSummary();
      this.targetMerchant = new MerchantSummary();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orderId =
        _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      this.financialOrderType =
        _data["financialOrderType"] !== undefined
          ? _data["financialOrderType"]
          : <any>null;
      this.financialOrderState =
        _data["financialOrderState"] !== undefined
          ? _data["financialOrderState"]
          : <any>null;
      this.firstVerifierUserId =
        _data["firstVerifierUserId"] !== undefined
          ? _data["firstVerifierUserId"]
          : <any>null;
      this.firstVerifierUserEmail =
        _data["firstVerifierUserEmail"] !== undefined
          ? _data["firstVerifierUserEmail"]
          : <any>null;
      this.secondVerifierUserId =
        _data["secondVerifierUserId"] !== undefined
          ? _data["secondVerifierUserId"]
          : <any>null;
      this.secondVerifierUserEmail =
        _data["secondVerifierUserEmail"] !== undefined
          ? _data["secondVerifierUserEmail"]
          : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.baseMerchant = _data["baseMerchant"]
        ? MerchantSummary.fromJS(_data["baseMerchant"])
        : new MerchantSummary();
      this.targetMerchant = _data["targetMerchant"]
        ? MerchantSummary.fromJS(_data["targetMerchant"])
        : new MerchantSummary();
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
    }
  }

  static fromJS(data: any): FinancialOrder {
    data = typeof data === "object" ? data : {};
    let result = new FinancialOrder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["financialOrderType"] =
      this.financialOrderType !== undefined
        ? this.financialOrderType
        : <any>null;
    data["financialOrderState"] =
      this.financialOrderState !== undefined
        ? this.financialOrderState
        : <any>null;
    data["firstVerifierUserId"] =
      this.firstVerifierUserId !== undefined
        ? this.firstVerifierUserId
        : <any>null;
    data["firstVerifierUserEmail"] =
      this.firstVerifierUserEmail !== undefined
        ? this.firstVerifierUserEmail
        : <any>null;
    data["secondVerifierUserId"] =
      this.secondVerifierUserId !== undefined
        ? this.secondVerifierUserId
        : <any>null;
    data["secondVerifierUserEmail"] =
      this.secondVerifierUserEmail !== undefined
        ? this.secondVerifierUserEmail
        : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["baseMerchant"] = this.baseMerchant
      ? this.baseMerchant.toJSON()
      : <any>null;
    data["targetMerchant"] = this.targetMerchant
      ? this.targetMerchant.toJSON()
      : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    return data;
  }
}

export interface IFinancialOrder {
  orderId: number;
  amount: number;
  currency: Currency;
  financialOrderType: FinancialOrderType;
  financialOrderState: FinancialOrderState;
  firstVerifierUserId?: string | null;
  firstVerifierUserEmail?: string | null;
  secondVerifierUserId?: string | null;
  secondVerifierUserEmail?: string | null;
  createdTime: Date;
  baseMerchant: MerchantSummary;
  targetMerchant: MerchantSummary;
  description?: string | null;
}

export enum FinancialOrderState {
  Completed = "Completed",
  Failed = "Failed",
  Unverified = "Unverified",
  Created = "Created",
  Rejecting = "Rejecting",
  Verifying = "Verifying",
}

export class GatewayList implements IGatewayList {
  gatewayListId!: number;
  name!: string;
  branch!: BranchLight;
  gatewayListPaymentProfiles!: GatewayListPaymentProfile[];

  constructor(data?: IGatewayList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.branch = new BranchLight();
      this.gatewayListPaymentProfiles = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.gatewayListId =
        _data["gatewayListId"] !== undefined
          ? _data["gatewayListId"]
          : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.branch = _data["branch"]
        ? BranchLight.fromJS(_data["branch"])
        : new BranchLight();
      if (Array.isArray(_data["gatewayListPaymentProfiles"])) {
        this.gatewayListPaymentProfiles = [] as any;
        for (let item of _data["gatewayListPaymentProfiles"])
          this.gatewayListPaymentProfiles!.push(
            GatewayListPaymentProfile.fromJS(item)
          );
      } else {
        this.gatewayListPaymentProfiles = <any>null;
      }
    }
  }

  static fromJS(data: any): GatewayList {
    data = typeof data === "object" ? data : {};
    let result = new GatewayList();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["gatewayListId"] =
      this.gatewayListId !== undefined ? this.gatewayListId : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["branch"] = this.branch ? this.branch.toJSON() : <any>null;
    if (Array.isArray(this.gatewayListPaymentProfiles)) {
      data["gatewayListPaymentProfiles"] = [];
      for (let item of this.gatewayListPaymentProfiles)
        data["gatewayListPaymentProfiles"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGatewayList {
  gatewayListId: number;
  name: string;
  branch: BranchLight;
  gatewayListPaymentProfiles: GatewayListPaymentProfile[];
}

export class GatewayListPaymentProfile implements IGatewayListPaymentProfile {
  paymentProfile!: PaymentProfile;
  useForSubMerchants!: boolean;

  constructor(data?: IGatewayListPaymentProfile) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.paymentProfile = new PaymentProfile();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentProfile = _data["paymentProfile"]
        ? PaymentProfile.fromJS(_data["paymentProfile"])
        : new PaymentProfile();
      this.useForSubMerchants =
        _data["useForSubMerchants"] !== undefined
          ? _data["useForSubMerchants"]
          : <any>null;
    }
  }

  static fromJS(data: any): GatewayListPaymentProfile {
    data = typeof data === "object" ? data : {};
    let result = new GatewayListPaymentProfile();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["paymentProfile"] = this.paymentProfile
      ? this.paymentProfile.toJSON()
      : <any>null;
    data["useForSubMerchants"] =
      this.useForSubMerchants !== undefined
        ? this.useForSubMerchants
        : <any>null;
    return data;
  }
}

export interface IGatewayListPaymentProfile {
  paymentProfile: PaymentProfile;
  useForSubMerchants: boolean;
}

export class PaymentProfile implements IPaymentProfile {
  paymentProfileId!: number;
  providerProfileId!: number;
  description!: string;
  name!: string;
  currency!: Currency;
  minAmount!: number;
  maxAmount!: number;
  imageUri1?: string | null;
  imageUri2?: string | null;

  constructor(data?: IPaymentProfile) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentProfileId =
        _data["paymentProfileId"] !== undefined
          ? _data["paymentProfileId"]
          : <any>null;
      this.providerProfileId =
        _data["providerProfileId"] !== undefined
          ? _data["providerProfileId"]
          : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      this.minAmount =
        _data["minAmount"] !== undefined ? _data["minAmount"] : <any>null;
      this.maxAmount =
        _data["maxAmount"] !== undefined ? _data["maxAmount"] : <any>null;
      this.imageUri1 =
        _data["imageUri1"] !== undefined ? _data["imageUri1"] : <any>null;
      this.imageUri2 =
        _data["imageUri2"] !== undefined ? _data["imageUri2"] : <any>null;
    }
  }

  static fromJS(data: any): PaymentProfile {
    data = typeof data === "object" ? data : {};
    let result = new PaymentProfile();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["paymentProfileId"] =
      this.paymentProfileId !== undefined ? this.paymentProfileId : <any>null;
    data["providerProfileId"] =
      this.providerProfileId !== undefined ? this.providerProfileId : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["minAmount"] =
      this.minAmount !== undefined ? this.minAmount : <any>null;
    data["maxAmount"] =
      this.maxAmount !== undefined ? this.maxAmount : <any>null;
    data["imageUri1"] =
      this.imageUri1 !== undefined ? this.imageUri1 : <any>null;
    data["imageUri2"] =
      this.imageUri2 !== undefined ? this.imageUri2 : <any>null;
    return data;
  }
}

export interface IPaymentProfile {
  paymentProfileId: number;
  providerProfileId: number;
  description: string;
  name: string;
  currency: Currency;
  minAmount: number;
  maxAmount: number;
  imageUri1?: string | null;
  imageUri2?: string | null;
}

export class CreateGatewayListRequest implements ICreateGatewayListRequest {
  name!: string;
  paymentProfiles!: PaymentProfileCreateRequest[];

  constructor(data?: ICreateGatewayListRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.paymentProfiles = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      if (Array.isArray(_data["paymentProfiles"])) {
        this.paymentProfiles = [] as any;
        for (let item of _data["paymentProfiles"])
          this.paymentProfiles!.push(PaymentProfileCreateRequest.fromJS(item));
      } else {
        this.paymentProfiles = <any>null;
      }
    }
  }

  static fromJS(data: any): CreateGatewayListRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateGatewayListRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name !== undefined ? this.name : <any>null;
    if (Array.isArray(this.paymentProfiles)) {
      data["paymentProfiles"] = [];
      for (let item of this.paymentProfiles)
        data["paymentProfiles"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICreateGatewayListRequest {
  name: string;
  paymentProfiles: PaymentProfileCreateRequest[];
}

export class PaymentProfileCreateRequest
  implements IPaymentProfileCreateRequest
{
  paymentProfileId!: number;
  useForSubMerchants!: boolean;

  constructor(data?: IPaymentProfileCreateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentProfileId =
        _data["paymentProfileId"] !== undefined
          ? _data["paymentProfileId"]
          : <any>null;
      this.useForSubMerchants =
        _data["useForSubMerchants"] !== undefined
          ? _data["useForSubMerchants"]
          : <any>null;
    }
  }

  static fromJS(data: any): PaymentProfileCreateRequest {
    data = typeof data === "object" ? data : {};
    let result = new PaymentProfileCreateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["paymentProfileId"] =
      this.paymentProfileId !== undefined ? this.paymentProfileId : <any>null;
    data["useForSubMerchants"] =
      this.useForSubMerchants !== undefined
        ? this.useForSubMerchants
        : <any>null;
    return data;
  }
}

export interface IPaymentProfileCreateRequest {
  paymentProfileId: number;
  useForSubMerchants: boolean;
}

export class PutGatewayListRequest implements IPutGatewayListRequest {
  name!: string;
  paymentProfiles!: PaymentProfileCreateRequest[];

  constructor(data?: IPutGatewayListRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.paymentProfiles = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      if (Array.isArray(_data["paymentProfiles"])) {
        this.paymentProfiles = [] as any;
        for (let item of _data["paymentProfiles"])
          this.paymentProfiles!.push(PaymentProfileCreateRequest.fromJS(item));
      } else {
        this.paymentProfiles = <any>null;
      }
    }
  }

  static fromJS(data: any): PutGatewayListRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutGatewayListRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name !== undefined ? this.name : <any>null;
    if (Array.isArray(this.paymentProfiles)) {
      data["paymentProfiles"] = [];
      for (let item of this.paymentProfiles)
        data["paymentProfiles"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPutGatewayListRequest {
  name: string;
  paymentProfiles: PaymentProfileCreateRequest[];
}

export class InvoiceSummary implements IInvoiceSummary {
  invoiceId!: number;
  merchant!: MerchantSummary;
  createdTime!: Date;
  beginTime!: Date;
  endTime!: Date;

  constructor(data?: IInvoiceSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.merchant = new MerchantSummary();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.invoiceId =
        _data["invoiceId"] !== undefined ? _data["invoiceId"] : <any>null;
      this.merchant = _data["merchant"]
        ? MerchantSummary.fromJS(_data["merchant"])
        : new MerchantSummary();
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.beginTime = _data["beginTime"]
        ? new Date(_data["beginTime"].toString())
        : <any>null;
      this.endTime = _data["endTime"]
        ? new Date(_data["endTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): InvoiceSummary {
    data = typeof data === "object" ? data : {};
    let result = new InvoiceSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["invoiceId"] =
      this.invoiceId !== undefined ? this.invoiceId : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["beginTime"] = this.beginTime
      ? this.beginTime.toISOString()
      : <any>null;
    data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
    return data;
  }
}

export interface IInvoiceSummary {
  invoiceId: number;
  merchant: MerchantSummary;
  createdTime: Date;
  beginTime: Date;
  endTime: Date;
}

export class Invoice implements IInvoice {
  invoiceId!: number;
  merchant!: Merchant;
  createdTime!: Date;
  beginTime!: Date;
  endTime!: Date;
  invoiceDetails!: InvoiceDetail[];

  constructor(data?: IInvoice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.merchant = new Merchant();
      this.invoiceDetails = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.invoiceId =
        _data["invoiceId"] !== undefined ? _data["invoiceId"] : <any>null;
      this.merchant = _data["merchant"]
        ? Merchant.fromJS(_data["merchant"])
        : new Merchant();
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.beginTime = _data["beginTime"]
        ? new Date(_data["beginTime"].toString())
        : <any>null;
      this.endTime = _data["endTime"]
        ? new Date(_data["endTime"].toString())
        : <any>null;
      if (Array.isArray(_data["invoiceDetails"])) {
        this.invoiceDetails = [] as any;
        for (let item of _data["invoiceDetails"])
          this.invoiceDetails!.push(InvoiceDetail.fromJS(item));
      } else {
        this.invoiceDetails = <any>null;
      }
    }
  }

  static fromJS(data: any): Invoice {
    data = typeof data === "object" ? data : {};
    let result = new Invoice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["invoiceId"] =
      this.invoiceId !== undefined ? this.invoiceId : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["beginTime"] = this.beginTime
      ? this.beginTime.toISOString()
      : <any>null;
    data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
    if (Array.isArray(this.invoiceDetails)) {
      data["invoiceDetails"] = [];
      for (let item of this.invoiceDetails)
        data["invoiceDetails"].push(item.toJSON());
    }
    return data;
  }
}

export interface IInvoice {
  invoiceId: number;
  merchant: Merchant;
  createdTime: Date;
  beginTime: Date;
  endTime: Date;
  invoiceDetails: InvoiceDetail[];
}

export class InvoiceDetail implements IInvoiceDetail {
  invoiceDetailId!: number;
  buyOrder?: BuyOrder | null;

  constructor(data?: IInvoiceDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.invoiceDetailId =
        _data["invoiceDetailId"] !== undefined
          ? _data["invoiceDetailId"]
          : <any>null;
      this.buyOrder = _data["buyOrder"]
        ? BuyOrder.fromJS(_data["buyOrder"])
        : <any>null;
    }
  }

  static fromJS(data: any): InvoiceDetail {
    data = typeof data === "object" ? data : {};
    let result = new InvoiceDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["invoiceDetailId"] =
      this.invoiceDetailId !== undefined ? this.invoiceDetailId : <any>null;
    data["buyOrder"] = this.buyOrder ? this.buyOrder.toJSON() : <any>null;
    return data;
  }
}

export interface IInvoiceDetail {
  invoiceDetailId: number;
  buyOrder?: BuyOrder | null;
}

export class MerchantCurrencyLimit implements IMerchantCurrencyLimit {
  currencyLimitId!: number;
  merchantId!: number;
  amount!: number;
  currency!: Currency;

  constructor(data?: IMerchantCurrencyLimit) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currencyLimitId =
        _data["currencyLimitId"] !== undefined
          ? _data["currencyLimitId"]
          : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
    }
  }

  static fromJS(data: any): MerchantCurrencyLimit {
    data = typeof data === "object" ? data : {};
    let result = new MerchantCurrencyLimit();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currencyLimitId"] =
      this.currencyLimitId !== undefined ? this.currencyLimitId : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    return data;
  }
}

export interface IMerchantCurrencyLimit {
  currencyLimitId: number;
  merchantId: number;
  amount: number;
  currency: Currency;
}

export class CreateMerchantCurrencyLimitRequest
  implements ICreateMerchantCurrencyLimitRequest
{
  currencyId!: number;
  amount!: number;

  constructor(data?: ICreateMerchantCurrencyLimitRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
    }
  }

  static fromJS(data: any): CreateMerchantCurrencyLimitRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateMerchantCurrencyLimitRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    return data;
  }
}

export interface ICreateMerchantCurrencyLimitRequest {
  currencyId: number;
  amount: number;
}

export class CreateMerchantRequest implements ICreateMerchantRequest {
  parentBranchId!: number;
  merchantName!: string;
  email!: string;
  externalReference!: string;
  priceListId?: number | null;
  saleManagerId?: number | null;
  gatewayListId?: number | null;
  description?: string | null;
  address?: MerchantAddress | null;
  timeZone?: string | null;
  website?: string | null;
  phoneNumber?: Phone | null;
  whatsappNumber?: Phone | null;

  constructor(data?: ICreateMerchantRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parentBranchId =
        _data["parentBranchId"] !== undefined
          ? _data["parentBranchId"]
          : <any>null;
      this.merchantName =
        _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.externalReference =
        _data["externalReference"] !== undefined
          ? _data["externalReference"]
          : <any>null;
      this.priceListId =
        _data["priceListId"] !== undefined ? _data["priceListId"] : <any>null;
      this.saleManagerId =
        _data["saleManagerId"] !== undefined
          ? _data["saleManagerId"]
          : <any>null;
      this.gatewayListId =
        _data["gatewayListId"] !== undefined
          ? _data["gatewayListId"]
          : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.address = _data["address"]
        ? MerchantAddress.fromJS(_data["address"])
        : <any>null;
      this.timeZone =
        _data["timeZone"] !== undefined ? _data["timeZone"] : <any>null;
      this.website =
        _data["website"] !== undefined ? _data["website"] : <any>null;
      this.phoneNumber = _data["phoneNumber"]
        ? Phone.fromJS(_data["phoneNumber"])
        : <any>null;
      this.whatsappNumber = _data["whatsappNumber"]
        ? Phone.fromJS(_data["whatsappNumber"])
        : <any>null;
    }
  }

  static fromJS(data: any): CreateMerchantRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateMerchantRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["parentBranchId"] =
      this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
    data["merchantName"] =
      this.merchantName !== undefined ? this.merchantName : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["externalReference"] =
      this.externalReference !== undefined ? this.externalReference : <any>null;
    data["priceListId"] =
      this.priceListId !== undefined ? this.priceListId : <any>null;
    data["saleManagerId"] =
      this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
    data["gatewayListId"] =
      this.gatewayListId !== undefined ? this.gatewayListId : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["address"] = this.address ? this.address.toJSON() : <any>null;
    data["timeZone"] = this.timeZone !== undefined ? this.timeZone : <any>null;
    data["website"] = this.website !== undefined ? this.website : <any>null;
    data["phoneNumber"] = this.phoneNumber
      ? this.phoneNumber.toJSON()
      : <any>null;
    data["whatsappNumber"] = this.whatsappNumber
      ? this.whatsappNumber.toJSON()
      : <any>null;
    return data;
  }
}

export interface ICreateMerchantRequest {
  parentBranchId: number;
  merchantName: string;
  email: string;
  externalReference: string;
  priceListId?: number | null;
  saleManagerId?: number | null;
  gatewayListId?: number | null;
  description?: string | null;
  address?: MerchantAddress | null;
  timeZone?: string | null;
  website?: string | null;
  phoneNumber?: Phone | null;
  whatsappNumber?: Phone | null;
}

export class UpdateMerchantRequest implements IUpdateMerchantRequest {
  exchangeTargetCurrencyId?: PatchOfInteger | null;
  invoiceThresholdDay?: PatchOfNullableInteger | null;
  address?: MerchantAddress | null;
  website?: PatchOfUri | null;
  phoneNumber?: PatchOfPhone | null;
  whatsappNumber?: PatchOfPhone | null;
  email?: PatchOfString | null;
  timeZone?: PatchOfString | null;
  isActive?: PatchOfNullableBoolean | null;

  constructor(data?: IUpdateMerchantRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.exchangeTargetCurrencyId = _data["exchangeTargetCurrencyId"]
        ? PatchOfInteger.fromJS(_data["exchangeTargetCurrencyId"])
        : <any>null;
      this.invoiceThresholdDay = _data["invoiceThresholdDay"]
        ? PatchOfNullableInteger.fromJS(_data["invoiceThresholdDay"])
        : <any>null;
      this.address = _data["address"]
        ? MerchantAddress.fromJS(_data["address"])
        : <any>null;
      this.website = _data["website"]
        ? PatchOfUri.fromJS(_data["website"])
        : <any>null;
      this.phoneNumber = _data["phoneNumber"]
        ? PatchOfPhone.fromJS(_data["phoneNumber"])
        : <any>null;
      this.whatsappNumber = _data["whatsappNumber"]
        ? PatchOfPhone.fromJS(_data["whatsappNumber"])
        : <any>null;
      this.email = _data["email"]
        ? PatchOfString.fromJS(_data["email"])
        : <any>null;
      this.timeZone = _data["timeZone"]
        ? PatchOfString.fromJS(_data["timeZone"])
        : <any>null;
      this.isActive = _data["isActive"]
        ? PatchOfNullableBoolean.fromJS(_data["isActive"])
        : <any>null;
    }
  }

  static fromJS(data: any): UpdateMerchantRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateMerchantRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["exchangeTargetCurrencyId"] = this.exchangeTargetCurrencyId
      ? this.exchangeTargetCurrencyId.toJSON()
      : <any>null;
    data["invoiceThresholdDay"] = this.invoiceThresholdDay
      ? this.invoiceThresholdDay.toJSON()
      : <any>null;
    data["address"] = this.address ? this.address.toJSON() : <any>null;
    data["website"] = this.website ? this.website.toJSON() : <any>null;
    data["phoneNumber"] = this.phoneNumber
      ? this.phoneNumber.toJSON()
      : <any>null;
    data["whatsappNumber"] = this.whatsappNumber
      ? this.whatsappNumber.toJSON()
      : <any>null;
    data["email"] = this.email ? this.email.toJSON() : <any>null;
    data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>null;
    data["isActive"] = this.isActive ? this.isActive.toJSON() : <any>null;
    return data;
  }
}

export interface IUpdateMerchantRequest {
  exchangeTargetCurrencyId?: PatchOfInteger | null;
  invoiceThresholdDay?: PatchOfNullableInteger | null;
  address?: MerchantAddress | null;
  website?: PatchOfUri | null;
  phoneNumber?: PatchOfPhone | null;
  whatsappNumber?: PatchOfPhone | null;
  email?: PatchOfString | null;
  timeZone?: PatchOfString | null;
  isActive?: PatchOfNullableBoolean | null;
}

export class PatchOfInteger implements IPatchOfInteger {
  value!: number;

  constructor(data?: IPatchOfInteger) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
    }
  }

  static fromJS(data: any): PatchOfInteger {
    data = typeof data === "object" ? data : {};
    let result = new PatchOfInteger();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value !== undefined ? this.value : <any>null;
    return data;
  }
}

export interface IPatchOfInteger {
  value: number;
}

export class PatchOfNullableInteger implements IPatchOfNullableInteger {
  value?: number | null;

  constructor(data?: IPatchOfNullableInteger) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
    }
  }

  static fromJS(data: any): PatchOfNullableInteger {
    data = typeof data === "object" ? data : {};
    let result = new PatchOfNullableInteger();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value !== undefined ? this.value : <any>null;
    return data;
  }
}

export interface IPatchOfNullableInteger {
  value?: number | null;
}

export class PatchOfPhone implements IPatchOfPhone {
  value?: Phone | null;

  constructor(data?: IPatchOfPhone) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"] ? Phone.fromJS(_data["value"]) : <any>null;
    }
  }

  static fromJS(data: any): PatchOfPhone {
    data = typeof data === "object" ? data : {};
    let result = new PatchOfPhone();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value ? this.value.toJSON() : <any>null;
    return data;
  }
}

export interface IPatchOfPhone {
  value?: Phone | null;
}

export class PatchOfNullableBoolean implements IPatchOfNullableBoolean {
  value?: boolean | null;

  constructor(data?: IPatchOfNullableBoolean) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
    }
  }

  static fromJS(data: any): PatchOfNullableBoolean {
    data = typeof data === "object" ? data : {};
    let result = new PatchOfNullableBoolean();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value !== undefined ? this.value : <any>null;
    return data;
  }
}

export interface IPatchOfNullableBoolean {
  value?: boolean | null;
}

export class UpdateMerchantSettingRequest
  implements IUpdateMerchantSettingRequest
{
  canCreatePaymentOrder?: PatchOfNullableBoolean | null;

  constructor(data?: IUpdateMerchantSettingRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.canCreatePaymentOrder = _data["canCreatePaymentOrder"]
        ? PatchOfNullableBoolean.fromJS(_data["canCreatePaymentOrder"])
        : <any>null;
    }
  }

  static fromJS(data: any): UpdateMerchantSettingRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateMerchantSettingRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["canCreatePaymentOrder"] = this.canCreatePaymentOrder
      ? this.canCreatePaymentOrder.toJSON()
      : <any>null;
    return data;
  }
}

export interface IUpdateMerchantSettingRequest {
  canCreatePaymentOrder?: PatchOfNullableBoolean | null;
}

export class PaymentOrder implements IPaymentOrder {
  paymentOrderId!: number;
  providerPaymentId?: number | null;
  merchant!: MerchantSummary;
  paymentUrl?: string | null;
  amount!: number;
  lastError?: string | null;
  currency!: Currency;
  paymentOrderState!: PaymentOrderState;
  createdTime!: Date;
  modifiedTime!: Date;

  constructor(data?: IPaymentOrder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.merchant = new MerchantSummary();
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentOrderId =
        _data["paymentOrderId"] !== undefined
          ? _data["paymentOrderId"]
          : <any>null;
      this.providerPaymentId =
        _data["providerPaymentId"] !== undefined
          ? _data["providerPaymentId"]
          : <any>null;
      this.merchant = _data["merchant"]
        ? MerchantSummary.fromJS(_data["merchant"])
        : new MerchantSummary();
      this.paymentUrl =
        _data["paymentUrl"] !== undefined ? _data["paymentUrl"] : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.lastError =
        _data["lastError"] !== undefined ? _data["lastError"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      this.paymentOrderState =
        _data["paymentOrderState"] !== undefined
          ? _data["paymentOrderState"]
          : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PaymentOrder {
    data = typeof data === "object" ? data : {};
    let result = new PaymentOrder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["paymentOrderId"] =
      this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
    data["providerPaymentId"] =
      this.providerPaymentId !== undefined ? this.providerPaymentId : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    data["paymentUrl"] =
      this.paymentUrl !== undefined ? this.paymentUrl : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["lastError"] =
      this.lastError !== undefined ? this.lastError : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["paymentOrderState"] =
      this.paymentOrderState !== undefined ? this.paymentOrderState : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPaymentOrder {
  paymentOrderId: number;
  providerPaymentId?: number | null;
  merchant: MerchantSummary;
  paymentUrl?: string | null;
  amount: number;
  lastError?: string | null;
  currency: Currency;
  paymentOrderState: PaymentOrderState;
  createdTime: Date;
  modifiedTime: Date;
}

export enum PaymentOrderState {
  Created = "Created",
  PaymentProviderCreated = "PaymentProviderCreated",
  PaymentProviderCaptured = "PaymentProviderCaptured",
  PaymentProviderDisputed = "PaymentProviderDisputed",
  Reserved = "Reserved",
  Captured = "Captured",
  Disputed = "Disputed",
  Failed = "Failed",
}

export class CreatePaymentOrderRequest implements ICreatePaymentOrderRequest {
  amount!: number;
  returnUrl!: string;
  paymentProfileId!: number;

  constructor(data?: ICreatePaymentOrderRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.returnUrl =
        _data["returnUrl"] !== undefined ? _data["returnUrl"] : <any>null;
      this.paymentProfileId =
        _data["paymentProfileId"] !== undefined
          ? _data["paymentProfileId"]
          : <any>null;
    }
  }

  static fromJS(data: any): CreatePaymentOrderRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreatePaymentOrderRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["returnUrl"] =
      this.returnUrl !== undefined ? this.returnUrl : <any>null;
    data["paymentProfileId"] =
      this.paymentProfileId !== undefined ? this.paymentProfileId : <any>null;
    return data;
  }
}

export interface ICreatePaymentOrderRequest {
  amount: number;
  returnUrl: string;
  paymentProfileId: number;
}

export class PaymentOrderSummary implements IPaymentOrderSummary {
  paymentOrderId!: number;
  amount!: number;
  currency!: Currency;
  paymentOrderState!: PaymentOrderState;
  stateId!: number;
  createdTime!: Date;

  constructor(data?: IPaymentOrderSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentOrderId =
        _data["paymentOrderId"] !== undefined
          ? _data["paymentOrderId"]
          : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      this.paymentOrderState =
        _data["paymentOrderState"] !== undefined
          ? _data["paymentOrderState"]
          : <any>null;
      this.stateId =
        _data["stateId"] !== undefined ? _data["stateId"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PaymentOrderSummary {
    data = typeof data === "object" ? data : {};
    let result = new PaymentOrderSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["paymentOrderId"] =
      this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["paymentOrderState"] =
      this.paymentOrderState !== undefined ? this.paymentOrderState : <any>null;
    data["stateId"] = this.stateId !== undefined ? this.stateId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPaymentOrderSummary {
  paymentOrderId: number;
  amount: number;
  currency: Currency;
  paymentOrderState: PaymentOrderState;
  stateId: number;
  createdTime: Date;
}

export class PaymentOrderStateLog implements IPaymentOrderStateLog {
  paymentOrderStateLogId!: number;
  state!: PaymentOrderState;
  stateId!: number;
  error?: string | null;
  createdTime!: Date;

  constructor(data?: IPaymentOrderStateLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentOrderStateLogId =
        _data["paymentOrderStateLogId"] !== undefined
          ? _data["paymentOrderStateLogId"]
          : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.stateId =
        _data["stateId"] !== undefined ? _data["stateId"] : <any>null;
      this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PaymentOrderStateLog {
    data = typeof data === "object" ? data : {};
    let result = new PaymentOrderStateLog();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["paymentOrderStateLogId"] =
      this.paymentOrderStateLogId !== undefined
        ? this.paymentOrderStateLogId
        : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["stateId"] = this.stateId !== undefined ? this.stateId : <any>null;
    data["error"] = this.error !== undefined ? this.error : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPaymentOrderStateLog {
  paymentOrderStateLogId: number;
  state: PaymentOrderState;
  stateId: number;
  error?: string | null;
  createdTime: Date;
}

export class PriceList implements IPriceList {
  priceListId!: number;
  branchId!: number;
  merchantId!: number;
  priceListName?: string | null;
  parentPriceList?: PriceListSummary | null;
  assignedBranchId?: number | null;
  priceLists?: PriceList[] | null;

  constructor(data?: IPriceList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.priceListId =
        _data["priceListId"] !== undefined ? _data["priceListId"] : <any>null;
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.priceListName =
        _data["priceListName"] !== undefined
          ? _data["priceListName"]
          : <any>null;
      this.parentPriceList = _data["parentPriceList"]
        ? PriceListSummary.fromJS(_data["parentPriceList"])
        : <any>null;
      this.assignedBranchId =
        _data["assignedBranchId"] !== undefined
          ? _data["assignedBranchId"]
          : <any>null;
      if (Array.isArray(_data["priceLists"])) {
        this.priceLists = [] as any;
        for (let item of _data["priceLists"])
          this.priceLists!.push(PriceList.fromJS(item));
      } else {
        this.priceLists = <any>null;
      }
    }
  }

  static fromJS(data: any): PriceList {
    data = typeof data === "object" ? data : {};
    let result = new PriceList();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["priceListId"] =
      this.priceListId !== undefined ? this.priceListId : <any>null;
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["priceListName"] =
      this.priceListName !== undefined ? this.priceListName : <any>null;
    data["parentPriceList"] = this.parentPriceList
      ? this.parentPriceList.toJSON()
      : <any>null;
    data["assignedBranchId"] =
      this.assignedBranchId !== undefined ? this.assignedBranchId : <any>null;
    if (Array.isArray(this.priceLists)) {
      data["priceLists"] = [];
      for (let item of this.priceLists) data["priceLists"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPriceList {
  priceListId: number;
  branchId: number;
  merchantId: number;
  priceListName?: string | null;
  parentPriceList?: PriceListSummary | null;
  assignedBranchId?: number | null;
  priceLists?: PriceList[] | null;
}

export class CreatePriceListRequest implements ICreatePriceListRequest {
  priceListName!: string;
  parentPriceListId?: number | null;

  constructor(data?: ICreatePriceListRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.priceListName =
        _data["priceListName"] !== undefined
          ? _data["priceListName"]
          : <any>null;
      this.parentPriceListId =
        _data["parentPriceListId"] !== undefined
          ? _data["parentPriceListId"]
          : <any>null;
    }
  }

  static fromJS(data: any): CreatePriceListRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreatePriceListRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["priceListName"] =
      this.priceListName !== undefined ? this.priceListName : <any>null;
    data["parentPriceListId"] =
      this.parentPriceListId !== undefined ? this.parentPriceListId : <any>null;
    return data;
  }
}

export interface ICreatePriceListRequest {
  priceListName: string;
  parentPriceListId?: number | null;
}

export class BuyPrice implements IBuyPrice {
  product!: ProductSummary;
  regions?: Region[] | null;
  rules!: BuyPriceRule[];

  constructor(data?: IBuyPrice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.product = new ProductSummary();
      this.rules = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.product = _data["product"]
        ? ProductSummary.fromJS(_data["product"])
        : new ProductSummary();
      if (Array.isArray(_data["regions"])) {
        this.regions = [] as any;
        for (let item of _data["regions"])
          this.regions!.push(Region.fromJS(item));
      } else {
        this.regions = <any>null;
      }
      if (Array.isArray(_data["rules"])) {
        this.rules = [] as any;
        for (let item of _data["rules"])
          this.rules!.push(BuyPriceRule.fromJS(item));
      } else {
        this.rules = <any>null;
      }
    }
  }

  static fromJS(data: any): BuyPrice {
    data = typeof data === "object" ? data : {};
    let result = new BuyPrice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["product"] = this.product ? this.product.toJSON() : <any>null;
    if (Array.isArray(this.regions)) {
      data["regions"] = [];
      for (let item of this.regions) data["regions"].push(item.toJSON());
    }
    if (Array.isArray(this.rules)) {
      data["rules"] = [];
      for (let item of this.rules) data["rules"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBuyPrice {
  product: ProductSummary;
  regions?: Region[] | null;
  rules: BuyPriceRule[];
}

export class ProductSummary implements IProductSummary {
  productId!: number;
  productName!: string;
  imageUrl?: string | null;
  providerSku!: string;
  upc?: string | null;
  isPhysical!: boolean;
  hasDescription!: boolean;
  categoryId!: number;
  currency!: Currency;

  constructor(data?: IProductSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.providerSku =
        _data["providerSku"] !== undefined ? _data["providerSku"] : <any>null;
      this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
      this.isPhysical =
        _data["isPhysical"] !== undefined ? _data["isPhysical"] : <any>null;
      this.hasDescription =
        _data["hasDescription"] !== undefined
          ? _data["hasDescription"]
          : <any>null;
      this.categoryId =
        _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
    }
  }

  static fromJS(data: any): ProductSummary {
    data = typeof data === "object" ? data : {};
    let result = new ProductSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["providerSku"] =
      this.providerSku !== undefined ? this.providerSku : <any>null;
    data["upc"] = this.upc !== undefined ? this.upc : <any>null;
    data["isPhysical"] =
      this.isPhysical !== undefined ? this.isPhysical : <any>null;
    data["hasDescription"] =
      this.hasDescription !== undefined ? this.hasDescription : <any>null;
    data["categoryId"] =
      this.categoryId !== undefined ? this.categoryId : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    return data;
  }
}

export interface IProductSummary {
  productId: number;
  productName: string;
  imageUrl?: string | null;
  providerSku: string;
  upc?: string | null;
  isPhysical: boolean;
  hasDescription: boolean;
  categoryId: number;
  currency: Currency;
}

export class Region implements IRegion {
  regionId!: number;
  name!: string;
  code!: string;
  imageUrl?: string | null;

  constructor(data?: IRegion) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.regionId =
        _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
    }
  }

  static fromJS(data: any): Region {
    data = typeof data === "object" ? data : {};
    let result = new Region();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["code"] = this.code !== undefined ? this.code : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    return data;
  }
}

export interface IRegion {
  regionId: number;
  name: string;
  code: string;
  imageUrl?: string | null;
}

export class BuyPriceRule implements IBuyPriceRule {
  faceValue!: PriceRange;
  priceValue!: number;
  consumerTax!: number;
  consumerFee!: number;
  resellPriceAmount!: PriceRange;
  consumerPriceAmount!: PriceRange;

  constructor(data?: IBuyPriceRule) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.faceValue = new PriceRange();
      this.resellPriceAmount = new PriceRange();
      this.consumerPriceAmount = new PriceRange();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.faceValue = _data["faceValue"]
        ? PriceRange.fromJS(_data["faceValue"])
        : new PriceRange();
      this.priceValue =
        _data["priceValue"] !== undefined ? _data["priceValue"] : <any>null;
      this.consumerTax =
        _data["consumerTax"] !== undefined ? _data["consumerTax"] : <any>null;
      this.consumerFee =
        _data["consumerFee"] !== undefined ? _data["consumerFee"] : <any>null;
      this.resellPriceAmount = _data["resellPriceAmount"]
        ? PriceRange.fromJS(_data["resellPriceAmount"])
        : new PriceRange();
      this.consumerPriceAmount = _data["consumerPriceAmount"]
        ? PriceRange.fromJS(_data["consumerPriceAmount"])
        : new PriceRange();
    }
  }

  static fromJS(data: any): BuyPriceRule {
    data = typeof data === "object" ? data : {};
    let result = new BuyPriceRule();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["faceValue"] = this.faceValue ? this.faceValue.toJSON() : <any>null;
    data["priceValue"] =
      this.priceValue !== undefined ? this.priceValue : <any>null;
    data["consumerTax"] =
      this.consumerTax !== undefined ? this.consumerTax : <any>null;
    data["consumerFee"] =
      this.consumerFee !== undefined ? this.consumerFee : <any>null;
    data["resellPriceAmount"] = this.resellPriceAmount
      ? this.resellPriceAmount.toJSON()
      : <any>null;
    data["consumerPriceAmount"] = this.consumerPriceAmount
      ? this.consumerPriceAmount.toJSON()
      : <any>null;
    return data;
  }
}

export interface IBuyPriceRule {
  faceValue: PriceRange;
  priceValue: number;
  consumerTax: number;
  consumerFee: number;
  resellPriceAmount: PriceRange;
  consumerPriceAmount: PriceRange;
}

export class PriceRange implements IPriceRange {
  start!: number;
  end?: number | null;
  endValue!: number;
  isEndless!: boolean;

  constructor(data?: IPriceRange) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.start = _data["start"] !== undefined ? _data["start"] : <any>null;
      this.end = _data["end"] !== undefined ? _data["end"] : <any>null;
      this.endValue =
        _data["endValue"] !== undefined ? _data["endValue"] : <any>null;
      this.isEndless =
        _data["isEndless"] !== undefined ? _data["isEndless"] : <any>null;
    }
  }

  static fromJS(data: any): PriceRange {
    data = typeof data === "object" ? data : {};
    let result = new PriceRange();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["start"] = this.start !== undefined ? this.start : <any>null;
    data["end"] = this.end !== undefined ? this.end : <any>null;
    data["endValue"] = this.endValue !== undefined ? this.endValue : <any>null;
    data["isEndless"] =
      this.isEndless !== undefined ? this.isEndless : <any>null;
    return data;
  }
}

export interface IPriceRange {
  start: number;
  end?: number | null;
  endValue: number;
  isEndless: boolean;
}

export class PriceView implements IPriceView {
  price!: Price;
  priceResults!: PriceResult[];

  constructor(data?: IPriceView) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.price = new Price();
      this.priceResults = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.price = _data["price"] ? Price.fromJS(_data["price"]) : new Price();
      if (Array.isArray(_data["priceResults"])) {
        this.priceResults = [] as any;
        for (let item of _data["priceResults"])
          this.priceResults!.push(PriceResult.fromJS(item));
      } else {
        this.priceResults = <any>null;
      }
    }
  }

  static fromJS(data: any): PriceView {
    data = typeof data === "object" ? data : {};
    let result = new PriceView();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["price"] = this.price ? this.price.toJSON() : <any>null;
    if (Array.isArray(this.priceResults)) {
      data["priceResults"] = [];
      for (let item of this.priceResults)
        data["priceResults"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPriceView {
  price: Price;
  priceResults: PriceResult[];
}

export class Price implements IPrice {
  product!: ProductSummary;
  currency!: Currency;
  regions?: Region[] | null;
  isRoot!: boolean;
  rules!: PriceRule[];

  constructor(data?: IPrice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.product = new ProductSummary();
      this.currency = new Currency();
      this.rules = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.product = _data["product"]
        ? ProductSummary.fromJS(_data["product"])
        : new ProductSummary();
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      if (Array.isArray(_data["regions"])) {
        this.regions = [] as any;
        for (let item of _data["regions"])
          this.regions!.push(Region.fromJS(item));
      } else {
        this.regions = <any>null;
      }
      this.isRoot = _data["isRoot"] !== undefined ? _data["isRoot"] : <any>null;
      if (Array.isArray(_data["rules"])) {
        this.rules = [] as any;
        for (let item of _data["rules"])
          this.rules!.push(PriceRule.fromJS(item));
      } else {
        this.rules = <any>null;
      }
    }
  }

  static fromJS(data: any): Price {
    data = typeof data === "object" ? data : {};
    let result = new Price();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["product"] = this.product ? this.product.toJSON() : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    if (Array.isArray(this.regions)) {
      data["regions"] = [];
      for (let item of this.regions) data["regions"].push(item.toJSON());
    }
    data["isRoot"] = this.isRoot !== undefined ? this.isRoot : <any>null;
    if (Array.isArray(this.rules)) {
      data["rules"] = [];
      for (let item of this.rules) data["rules"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPrice {
  product: ProductSummary;
  currency: Currency;
  regions?: Region[] | null;
  isRoot: boolean;
  rules: PriceRule[];
}

export class PriceRule implements IPriceRule {
  faceValue!: PriceRange;
  priceValueMode?: PriceValueMode | null;
  priceValue?: number | null;
  step?: number | null;
  minBenefit?: number | null;
  consumerTax?: number | null;
  consumerFee?: number | null;
  isActive?: boolean | null;
  permission!: PriceRulePermission;

  constructor(data?: IPriceRule) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.faceValue = new PriceRange();
      this.permission = new PriceRulePermission();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.faceValue = _data["faceValue"]
        ? PriceRange.fromJS(_data["faceValue"])
        : new PriceRange();
      this.priceValueMode =
        _data["priceValueMode"] !== undefined
          ? _data["priceValueMode"]
          : <any>null;
      this.priceValue =
        _data["priceValue"] !== undefined ? _data["priceValue"] : <any>null;
      this.step = _data["step"] !== undefined ? _data["step"] : <any>null;
      this.minBenefit =
        _data["minBenefit"] !== undefined ? _data["minBenefit"] : <any>null;
      this.consumerTax =
        _data["consumerTax"] !== undefined ? _data["consumerTax"] : <any>null;
      this.consumerFee =
        _data["consumerFee"] !== undefined ? _data["consumerFee"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.permission = _data["permission"]
        ? PriceRulePermission.fromJS(_data["permission"])
        : new PriceRulePermission();
    }
  }

  static fromJS(data: any): PriceRule {
    data = typeof data === "object" ? data : {};
    let result = new PriceRule();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["faceValue"] = this.faceValue ? this.faceValue.toJSON() : <any>null;
    data["priceValueMode"] =
      this.priceValueMode !== undefined ? this.priceValueMode : <any>null;
    data["priceValue"] =
      this.priceValue !== undefined ? this.priceValue : <any>null;
    data["step"] = this.step !== undefined ? this.step : <any>null;
    data["minBenefit"] =
      this.minBenefit !== undefined ? this.minBenefit : <any>null;
    data["consumerTax"] =
      this.consumerTax !== undefined ? this.consumerTax : <any>null;
    data["consumerFee"] =
      this.consumerFee !== undefined ? this.consumerFee : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["permission"] = this.permission ? this.permission.toJSON() : <any>null;
    return data;
  }
}

export interface IPriceRule {
  faceValue: PriceRange;
  priceValueMode?: PriceValueMode | null;
  priceValue?: number | null;
  step?: number | null;
  minBenefit?: number | null;
  consumerTax?: number | null;
  consumerFee?: number | null;
  isActive?: boolean | null;
  permission: PriceRulePermission;
}

export enum PriceValueMode {
  FaceValue = 0,
  BuyValue = 1,
}

export class PriceRulePermission implements IPriceRulePermission {
  canSetPriceModeToFaceValue?: boolean | null;
  minMinBenefit?: number | null;
  maxConsumerFee?: number | null;
  maxConsumerTax?: number | null;

  constructor(data?: IPriceRulePermission) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.canSetPriceModeToFaceValue =
        _data["canSetPriceModeToFaceValue"] !== undefined
          ? _data["canSetPriceModeToFaceValue"]
          : <any>null;
      this.minMinBenefit =
        _data["minMinBenefit"] !== undefined
          ? _data["minMinBenefit"]
          : <any>null;
      this.maxConsumerFee =
        _data["maxConsumerFee"] !== undefined
          ? _data["maxConsumerFee"]
          : <any>null;
      this.maxConsumerTax =
        _data["maxConsumerTax"] !== undefined
          ? _data["maxConsumerTax"]
          : <any>null;
    }
  }

  static fromJS(data: any): PriceRulePermission {
    data = typeof data === "object" ? data : {};
    let result = new PriceRulePermission();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["canSetPriceModeToFaceValue"] =
      this.canSetPriceModeToFaceValue !== undefined
        ? this.canSetPriceModeToFaceValue
        : <any>null;
    data["minMinBenefit"] =
      this.minMinBenefit !== undefined ? this.minMinBenefit : <any>null;
    data["maxConsumerFee"] =
      this.maxConsumerFee !== undefined ? this.maxConsumerFee : <any>null;
    data["maxConsumerTax"] =
      this.maxConsumerTax !== undefined ? this.maxConsumerTax : <any>null;
    return data;
  }
}

export interface IPriceRulePermission {
  canSetPriceModeToFaceValue?: boolean | null;
  minMinBenefit?: number | null;
  maxConsumerFee?: number | null;
  maxConsumerTax?: number | null;
}

export class PriceResult implements IPriceResult {
  buyingRule?: PriceRule | null;
  masterRule?: PriceRule | null;
  rule!: PriceRule;
  buyingPriceAmount?: PriceRange | null;
  resellPriceAmount?: PriceRange | null;
  consumerPriceAmount?: PriceRange | null;
  benefit?: number | null;
  errors!: PriceRuleError[];

  constructor(data?: IPriceResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.rule = new PriceRule();
      this.errors = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.buyingRule = _data["buyingRule"]
        ? PriceRule.fromJS(_data["buyingRule"])
        : <any>null;
      this.masterRule = _data["masterRule"]
        ? PriceRule.fromJS(_data["masterRule"])
        : <any>null;
      this.rule = _data["rule"]
        ? PriceRule.fromJS(_data["rule"])
        : new PriceRule();
      this.buyingPriceAmount = _data["buyingPriceAmount"]
        ? PriceRange.fromJS(_data["buyingPriceAmount"])
        : <any>null;
      this.resellPriceAmount = _data["resellPriceAmount"]
        ? PriceRange.fromJS(_data["resellPriceAmount"])
        : <any>null;
      this.consumerPriceAmount = _data["consumerPriceAmount"]
        ? PriceRange.fromJS(_data["consumerPriceAmount"])
        : <any>null;
      this.benefit =
        _data["benefit"] !== undefined ? _data["benefit"] : <any>null;
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"])
          this.errors!.push(PriceRuleError.fromJS(item));
      } else {
        this.errors = <any>null;
      }
    }
  }

  static fromJS(data: any): PriceResult {
    data = typeof data === "object" ? data : {};
    let result = new PriceResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["buyingRule"] = this.buyingRule ? this.buyingRule.toJSON() : <any>null;
    data["masterRule"] = this.masterRule ? this.masterRule.toJSON() : <any>null;
    data["rule"] = this.rule ? this.rule.toJSON() : <any>null;
    data["buyingPriceAmount"] = this.buyingPriceAmount
      ? this.buyingPriceAmount.toJSON()
      : <any>null;
    data["resellPriceAmount"] = this.resellPriceAmount
      ? this.resellPriceAmount.toJSON()
      : <any>null;
    data["consumerPriceAmount"] = this.consumerPriceAmount
      ? this.consumerPriceAmount.toJSON()
      : <any>null;
    data["benefit"] = this.benefit !== undefined ? this.benefit : <any>null;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPriceResult {
  buyingRule?: PriceRule | null;
  masterRule?: PriceRule | null;
  rule: PriceRule;
  buyingPriceAmount?: PriceRange | null;
  resellPriceAmount?: PriceRange | null;
  consumerPriceAmount?: PriceRange | null;
  benefit?: number | null;
  errors: PriceRuleError[];
}

export class PriceRuleError implements IPriceRuleError {
  propertyName!: string;
  message!: string;

  constructor(data?: IPriceRuleError) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyName =
        _data["propertyName"] !== undefined ? _data["propertyName"] : <any>null;
      this.message =
        _data["message"] !== undefined ? _data["message"] : <any>null;
    }
  }

  static fromJS(data: any): PriceRuleError {
    data = typeof data === "object" ? data : {};
    let result = new PriceRuleError();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["propertyName"] =
      this.propertyName !== undefined ? this.propertyName : <any>null;
    data["message"] = this.message !== undefined ? this.message : <any>null;
    return data;
  }
}

export interface IPriceRuleError {
  propertyName: string;
  message: string;
}

export class ProductPriceRule implements IProductPriceRule {
  productId!: number;
  rules!: PriceRule[];

  constructor(data?: IProductPriceRule) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.rules = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      if (Array.isArray(_data["rules"])) {
        this.rules = [] as any;
        for (let item of _data["rules"])
          this.rules!.push(PriceRule.fromJS(item));
      } else {
        this.rules = <any>null;
      }
    }
  }

  static fromJS(data: any): ProductPriceRule {
    data = typeof data === "object" ? data : {};
    let result = new ProductPriceRule();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    if (Array.isArray(this.rules)) {
      data["rules"] = [];
      for (let item of this.rules) data["rules"].push(item.toJSON());
    }
    return data;
  }
}

export interface IProductPriceRule {
  productId: number;
  rules: PriceRule[];
}

export class Product implements IProduct {
  productId!: number;
  productName!: string;
  regions?: Region[] | null;
  providerSku!: string;
  canPreOrder?: boolean | null;
  canImmediate?: boolean | null;
  isActive?: boolean | null;
  upc?: string | null;
  isPhysical!: boolean;
  description?: string | null;
  categoryId!: number;
  imageUrl?: string | null;
  currency!: Currency;

  constructor(data?: IProduct) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      if (Array.isArray(_data["regions"])) {
        this.regions = [] as any;
        for (let item of _data["regions"])
          this.regions!.push(Region.fromJS(item));
      } else {
        this.regions = <any>null;
      }
      this.providerSku =
        _data["providerSku"] !== undefined ? _data["providerSku"] : <any>null;
      this.canPreOrder =
        _data["canPreOrder"] !== undefined ? _data["canPreOrder"] : <any>null;
      this.canImmediate =
        _data["canImmediate"] !== undefined ? _data["canImmediate"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
      this.isPhysical =
        _data["isPhysical"] !== undefined ? _data["isPhysical"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.categoryId =
        _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
    }
  }

  static fromJS(data: any): Product {
    data = typeof data === "object" ? data : {};
    let result = new Product();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    if (Array.isArray(this.regions)) {
      data["regions"] = [];
      for (let item of this.regions) data["regions"].push(item.toJSON());
    }
    data["providerSku"] =
      this.providerSku !== undefined ? this.providerSku : <any>null;
    data["canPreOrder"] =
      this.canPreOrder !== undefined ? this.canPreOrder : <any>null;
    data["canImmediate"] =
      this.canImmediate !== undefined ? this.canImmediate : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["upc"] = this.upc !== undefined ? this.upc : <any>null;
    data["isPhysical"] =
      this.isPhysical !== undefined ? this.isPhysical : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["categoryId"] =
      this.categoryId !== undefined ? this.categoryId : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    return data;
  }
}

export interface IProduct {
  productId: number;
  productName: string;
  regions?: Region[] | null;
  providerSku: string;
  canPreOrder?: boolean | null;
  canImmediate?: boolean | null;
  isActive?: boolean | null;
  upc?: string | null;
  isPhysical: boolean;
  description?: string | null;
  categoryId: number;
  imageUrl?: string | null;
  currency: Currency;
}

export class CreateProductRequest implements ICreateProductRequest {
  productName!: string;
  providerSku!: string;
  currencyId!: number;
  description?: string | null;
  upc?: string | null;
  categoryId!: number;
  imageUrl?: string | null;

  constructor(data?: ICreateProductRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.providerSku =
        _data["providerSku"] !== undefined ? _data["providerSku"] : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
      this.categoryId =
        _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
    }
  }

  static fromJS(data: any): CreateProductRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateProductRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    data["providerSku"] =
      this.providerSku !== undefined ? this.providerSku : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["upc"] = this.upc !== undefined ? this.upc : <any>null;
    data["categoryId"] =
      this.categoryId !== undefined ? this.categoryId : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    return data;
  }
}

export interface ICreateProductRequest {
  productName: string;
  providerSku: string;
  currencyId: number;
  description?: string | null;
  upc?: string | null;
  categoryId: number;
  imageUrl?: string | null;
}

export class UpdateProductRequest implements IUpdateProductRequest {
  regionIds?: PatchOfInt32Of | null;
  categoryId?: PatchOfInteger | null;
  imageUrl?: PatchOfUri | null;
  productName?: PatchOfString | null;
  description?: PatchOfString | null;

  constructor(data?: IUpdateProductRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.regionIds = _data["regionIds"]
        ? PatchOfInt32Of.fromJS(_data["regionIds"])
        : <any>null;
      this.categoryId = _data["categoryId"]
        ? PatchOfInteger.fromJS(_data["categoryId"])
        : <any>null;
      this.imageUrl = _data["imageUrl"]
        ? PatchOfUri.fromJS(_data["imageUrl"])
        : <any>null;
      this.productName = _data["productName"]
        ? PatchOfString.fromJS(_data["productName"])
        : <any>null;
      this.description = _data["description"]
        ? PatchOfString.fromJS(_data["description"])
        : <any>null;
    }
  }

  static fromJS(data: any): UpdateProductRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateProductRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["regionIds"] = this.regionIds ? this.regionIds.toJSON() : <any>null;
    data["categoryId"] = this.categoryId ? this.categoryId.toJSON() : <any>null;
    data["imageUrl"] = this.imageUrl ? this.imageUrl.toJSON() : <any>null;
    data["productName"] = this.productName
      ? this.productName.toJSON()
      : <any>null;
    data["description"] = this.description
      ? this.description.toJSON()
      : <any>null;
    return data;
  }
}

export interface IUpdateProductRequest {
  regionIds?: PatchOfInt32Of | null;
  categoryId?: PatchOfInteger | null;
  imageUrl?: PatchOfUri | null;
  productName?: PatchOfString | null;
  description?: PatchOfString | null;
}

export class PatchOfInt32Of implements IPatchOfInt32Of {
  value?: number[] | null;

  constructor(data?: IPatchOfInt32Of) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["value"])) {
        this.value = [] as any;
        for (let item of _data["value"]) this.value!.push(item);
      } else {
        this.value = <any>null;
      }
    }
  }

  static fromJS(data: any): PatchOfInt32Of {
    data = typeof data === "object" ? data : {};
    let result = new PatchOfInt32Of();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.value)) {
      data["value"] = [];
      for (let item of this.value) data["value"].push(item);
    }
    return data;
  }
}

export interface IPatchOfInt32Of {
  value?: number[] | null;
}

export class ProductItem implements IProductItem {
  productId!: number;
  productName!: string;
  faceValue!: number;
  currency!: Currency;
  availableCount!: number;

  constructor(data?: IProductItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.faceValue =
        _data["faceValue"] !== undefined ? _data["faceValue"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      this.availableCount =
        _data["availableCount"] !== undefined
          ? _data["availableCount"]
          : <any>null;
    }
  }

  static fromJS(data: any): ProductItem {
    data = typeof data === "object" ? data : {};
    let result = new ProductItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    data["faceValue"] =
      this.faceValue !== undefined ? this.faceValue : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["availableCount"] =
      this.availableCount !== undefined ? this.availableCount : <any>null;
    return data;
  }
}

export interface IProductItem {
  productId: number;
  productName: string;
  faceValue: number;
  currency: Currency;
  availableCount: number;
}

export class CreateRegionRequest implements ICreateRegionRequest {
  name!: string;
  code!: string;
  imageUrl?: string | null;

  constructor(data?: ICreateRegionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
    }
  }

  static fromJS(data: any): CreateRegionRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateRegionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["code"] = this.code !== undefined ? this.code : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    return data;
  }
}

export interface ICreateRegionRequest {
  name: string;
  code: string;
  imageUrl?: string | null;
}

export class UpdateRegionRequest implements IUpdateRegionRequest {
  name?: PatchOfString | null;
  code?: PatchOfString | null;
  imageUrl?: PatchOfUri | null;

  constructor(data?: IUpdateRegionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"]
        ? PatchOfString.fromJS(_data["name"])
        : <any>null;
      this.code = _data["code"]
        ? PatchOfString.fromJS(_data["code"])
        : <any>null;
      this.imageUrl = _data["imageUrl"]
        ? PatchOfUri.fromJS(_data["imageUrl"])
        : <any>null;
    }
  }

  static fromJS(data: any): UpdateRegionRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateRegionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name ? this.name.toJSON() : <any>null;
    data["code"] = this.code ? this.code.toJSON() : <any>null;
    data["imageUrl"] = this.imageUrl ? this.imageUrl.toJSON() : <any>null;
    return data;
  }
}

export interface IUpdateRegionRequest {
  name?: PatchOfString | null;
  code?: PatchOfString | null;
  imageUrl?: PatchOfUri | null;
}

export class Report implements IReport {
  wallet!: Wallet;
  credit?: Wallet | null;
  customersCreditsAndWallets?: CustomerCreditAndWallet | null;
  customersAccounting!: CustomerAccountingReport[];
  officesAccounting!: OfficeAccountingReport[];
  saleManagersAccounting!: SaleManagerAccountingReport[];
  topProducts!: ProductReport[];

  constructor(data?: IReport) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.wallet = new Wallet();
      this.customersAccounting = [];
      this.officesAccounting = [];
      this.saleManagersAccounting = [];
      this.topProducts = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.wallet = _data["wallet"]
        ? Wallet.fromJS(_data["wallet"])
        : new Wallet();
      this.credit = _data["credit"]
        ? Wallet.fromJS(_data["credit"])
        : <any>null;
      this.customersCreditsAndWallets = _data["customersCreditsAndWallets"]
        ? CustomerCreditAndWallet.fromJS(_data["customersCreditsAndWallets"])
        : <any>null;
      if (Array.isArray(_data["customersAccounting"])) {
        this.customersAccounting = [] as any;
        for (let item of _data["customersAccounting"])
          this.customersAccounting!.push(CustomerAccountingReport.fromJS(item));
      } else {
        this.customersAccounting = <any>null;
      }
      if (Array.isArray(_data["officesAccounting"])) {
        this.officesAccounting = [] as any;
        for (let item of _data["officesAccounting"])
          this.officesAccounting!.push(OfficeAccountingReport.fromJS(item));
      } else {
        this.officesAccounting = <any>null;
      }
      if (Array.isArray(_data["saleManagersAccounting"])) {
        this.saleManagersAccounting = [] as any;
        for (let item of _data["saleManagersAccounting"])
          this.saleManagersAccounting!.push(
            SaleManagerAccountingReport.fromJS(item)
          );
      } else {
        this.saleManagersAccounting = <any>null;
      }
      if (Array.isArray(_data["topProducts"])) {
        this.topProducts = [] as any;
        for (let item of _data["topProducts"])
          this.topProducts!.push(ProductReport.fromJS(item));
      } else {
        this.topProducts = <any>null;
      }
    }
  }

  static fromJS(data: any): Report {
    data = typeof data === "object" ? data : {};
    let result = new Report();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>null;
    data["credit"] = this.credit ? this.credit.toJSON() : <any>null;
    data["customersCreditsAndWallets"] = this.customersCreditsAndWallets
      ? this.customersCreditsAndWallets.toJSON()
      : <any>null;
    if (Array.isArray(this.customersAccounting)) {
      data["customersAccounting"] = [];
      for (let item of this.customersAccounting)
        data["customersAccounting"].push(item.toJSON());
    }
    if (Array.isArray(this.officesAccounting)) {
      data["officesAccounting"] = [];
      for (let item of this.officesAccounting)
        data["officesAccounting"].push(item.toJSON());
    }
    if (Array.isArray(this.saleManagersAccounting)) {
      data["saleManagersAccounting"] = [];
      for (let item of this.saleManagersAccounting)
        data["saleManagersAccounting"].push(item.toJSON());
    }
    if (Array.isArray(this.topProducts)) {
      data["topProducts"] = [];
      for (let item of this.topProducts)
        data["topProducts"].push(item.toJSON());
    }
    return data;
  }
}

export interface IReport {
  wallet: Wallet;
  credit?: Wallet | null;
  customersCreditsAndWallets?: CustomerCreditAndWallet | null;
  customersAccounting: CustomerAccountingReport[];
  officesAccounting: OfficeAccountingReport[];
  saleManagersAccounting: SaleManagerAccountingReport[];
  topProducts: ProductReport[];
}

export class CustomerCreditAndWallet implements ICustomerCreditAndWallet {
  wallet?: CurrencyBalance[] | null;
  credit?: CurrencyBalance[] | null;

  constructor(data?: ICustomerCreditAndWallet) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["wallet"])) {
        this.wallet = [] as any;
        for (let item of _data["wallet"])
          this.wallet!.push(CurrencyBalance.fromJS(item));
      } else {
        this.wallet = <any>null;
      }
      if (Array.isArray(_data["credit"])) {
        this.credit = [] as any;
        for (let item of _data["credit"])
          this.credit!.push(CurrencyBalance.fromJS(item));
      } else {
        this.credit = <any>null;
      }
    }
  }

  static fromJS(data: any): CustomerCreditAndWallet {
    data = typeof data === "object" ? data : {};
    let result = new CustomerCreditAndWallet();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.wallet)) {
      data["wallet"] = [];
      for (let item of this.wallet) data["wallet"].push(item.toJSON());
    }
    if (Array.isArray(this.credit)) {
      data["credit"] = [];
      for (let item of this.credit) data["credit"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICustomerCreditAndWallet {
  wallet?: CurrencyBalance[] | null;
  credit?: CurrencyBalance[] | null;
}

export class CustomerAccountingReport implements ICustomerAccountingReport {
  saleAmount!: number;
  profit!: number;
  currency!: Currency;
  customer!: MerchantSummary;
  date!: Date;

  constructor(data?: ICustomerAccountingReport) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
      this.customer = new MerchantSummary();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.saleAmount =
        _data["saleAmount"] !== undefined ? _data["saleAmount"] : <any>null;
      this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      this.customer = _data["customer"]
        ? MerchantSummary.fromJS(_data["customer"])
        : new MerchantSummary();
      this.date = _data["date"]
        ? new Date(_data["date"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): CustomerAccountingReport {
    data = typeof data === "object" ? data : {};
    let result = new CustomerAccountingReport();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["saleAmount"] =
      this.saleAmount !== undefined ? this.saleAmount : <any>null;
    data["profit"] = this.profit !== undefined ? this.profit : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["customer"] = this.customer ? this.customer.toJSON() : <any>null;
    data["date"] = this.date ? formatDate(this.date) : <any>null;
    return data;
  }
}

export interface ICustomerAccountingReport {
  saleAmount: number;
  profit: number;
  currency: Currency;
  customer: MerchantSummary;
  date: Date;
}

export class OfficeAccountingReport implements IOfficeAccountingReport {
  saleAmount!: number;
  profit!: number;
  currency!: Currency;
  branch!: BranchSummary;
  date!: Date;

  constructor(data?: IOfficeAccountingReport) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
      this.branch = new BranchSummary();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.saleAmount =
        _data["saleAmount"] !== undefined ? _data["saleAmount"] : <any>null;
      this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      this.branch = _data["branch"]
        ? BranchSummary.fromJS(_data["branch"])
        : new BranchSummary();
      this.date = _data["date"]
        ? new Date(_data["date"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): OfficeAccountingReport {
    data = typeof data === "object" ? data : {};
    let result = new OfficeAccountingReport();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["saleAmount"] =
      this.saleAmount !== undefined ? this.saleAmount : <any>null;
    data["profit"] = this.profit !== undefined ? this.profit : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["branch"] = this.branch ? this.branch.toJSON() : <any>null;
    data["date"] = this.date ? formatDate(this.date) : <any>null;
    return data;
  }
}

export interface IOfficeAccountingReport {
  saleAmount: number;
  profit: number;
  currency: Currency;
  branch: BranchSummary;
  date: Date;
}

export class BranchSummary implements IBranchSummary {
  branchId!: number;
  branchName!: string;

  constructor(data?: IBranchSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.branchName =
        _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
    }
  }

  static fromJS(data: any): BranchSummary {
    data = typeof data === "object" ? data : {};
    let result = new BranchSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["branchName"] =
      this.branchName !== undefined ? this.branchName : <any>null;
    return data;
  }
}

export interface IBranchSummary {
  branchId: number;
  branchName: string;
}

export class SaleManagerAccountingReport
  implements ISaleManagerAccountingReport
{
  saleAmount!: number;
  profit!: number;
  currency!: Currency;
  saleManager?: SaleManagerSummary | null;
  date!: Date;

  constructor(data?: ISaleManagerAccountingReport) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.saleAmount =
        _data["saleAmount"] !== undefined ? _data["saleAmount"] : <any>null;
      this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      this.saleManager = _data["saleManager"]
        ? SaleManagerSummary.fromJS(_data["saleManager"])
        : <any>null;
      this.date = _data["date"]
        ? new Date(_data["date"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): SaleManagerAccountingReport {
    data = typeof data === "object" ? data : {};
    let result = new SaleManagerAccountingReport();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["saleAmount"] =
      this.saleAmount !== undefined ? this.saleAmount : <any>null;
    data["profit"] = this.profit !== undefined ? this.profit : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["saleManager"] = this.saleManager
      ? this.saleManager.toJSON()
      : <any>null;
    data["date"] = this.date ? formatDate(this.date) : <any>null;
    return data;
  }
}

export interface ISaleManagerAccountingReport {
  saleAmount: number;
  profit: number;
  currency: Currency;
  saleManager?: SaleManagerSummary | null;
  date: Date;
}

export class ProductReport implements IProductReport {
  product!: ProductSummary;
  saleCounts!: number;
  profit!: number;

  constructor(data?: IProductReport) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.product = new ProductSummary();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.product = _data["product"]
        ? ProductSummary.fromJS(_data["product"])
        : new ProductSummary();
      this.saleCounts =
        _data["saleCounts"] !== undefined ? _data["saleCounts"] : <any>null;
      this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
    }
  }

  static fromJS(data: any): ProductReport {
    data = typeof data === "object" ? data : {};
    let result = new ProductReport();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["product"] = this.product ? this.product.toJSON() : <any>null;
    data["saleCounts"] =
      this.saleCounts !== undefined ? this.saleCounts : <any>null;
    data["profit"] = this.profit !== undefined ? this.profit : <any>null;
    return data;
  }
}

export interface IProductReport {
  product: ProductSummary;
  saleCounts: number;
  profit: number;
}

export class ReportSummary implements IReportSummary {
  currency!: Currency;
  saleAmount!: number;
  count!: number;

  constructor(data?: IReportSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      this.saleAmount =
        _data["saleAmount"] !== undefined ? _data["saleAmount"] : <any>null;
      this.count = _data["count"] !== undefined ? _data["count"] : <any>null;
    }
  }

  static fromJS(data: any): ReportSummary {
    data = typeof data === "object" ? data : {};
    let result = new ReportSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["saleAmount"] =
      this.saleAmount !== undefined ? this.saleAmount : <any>null;
    data["count"] = this.count !== undefined ? this.count : <any>null;
    return data;
  }
}

export interface IReportSummary {
  currency: Currency;
  saleAmount: number;
  count: number;
}

export class SaleManager implements ISaleManager {
  saleManagerId!: number;
  name!: string;
  email!: string;
  phoneNumber?: string | null;
  isActive!: boolean;

  constructor(data?: ISaleManager) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.saleManagerId =
        _data["saleManagerId"] !== undefined
          ? _data["saleManagerId"]
          : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.phoneNumber =
        _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
    }
  }

  static fromJS(data: any): SaleManager {
    data = typeof data === "object" ? data : {};
    let result = new SaleManager();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["saleManagerId"] =
      this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["phoneNumber"] =
      this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    return data;
  }
}

export interface ISaleManager {
  saleManagerId: number;
  name: string;
  email: string;
  phoneNumber?: string | null;
  isActive: boolean;
}

export class CreateSaleManagerRequest implements ICreateSaleManagerRequest {
  name!: string;
  email!: string;
  userId!: string;
  phoneNumber?: string | null;

  constructor(data?: ICreateSaleManagerRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
      this.phoneNumber =
        _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
    }
  }

  static fromJS(data: any): CreateSaleManagerRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateSaleManagerRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["userId"] = this.userId !== undefined ? this.userId : <any>null;
    data["phoneNumber"] =
      this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
    return data;
  }
}

export interface ICreateSaleManagerRequest {
  name: string;
  email: string;
  userId: string;
  phoneNumber?: string | null;
}

export class UpdateSaleManagerRequest implements IUpdateSaleManagerRequest {
  name?: PatchOfString | null;
  email?: PatchOfString | null;
  phoneNumber?: PatchOfString | null;
  isActive?: PatchOfNullableBoolean | null;

  constructor(data?: IUpdateSaleManagerRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"]
        ? PatchOfString.fromJS(_data["name"])
        : <any>null;
      this.email = _data["email"]
        ? PatchOfString.fromJS(_data["email"])
        : <any>null;
      this.phoneNumber = _data["phoneNumber"]
        ? PatchOfString.fromJS(_data["phoneNumber"])
        : <any>null;
      this.isActive = _data["isActive"]
        ? PatchOfNullableBoolean.fromJS(_data["isActive"])
        : <any>null;
    }
  }

  static fromJS(data: any): UpdateSaleManagerRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateSaleManagerRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name ? this.name.toJSON() : <any>null;
    data["email"] = this.email ? this.email.toJSON() : <any>null;
    data["phoneNumber"] = this.phoneNumber
      ? this.phoneNumber.toJSON()
      : <any>null;
    data["isActive"] = this.isActive ? this.isActive.toJSON() : <any>null;
    return data;
  }
}

export interface IUpdateSaleManagerRequest {
  name?: PatchOfString | null;
  email?: PatchOfString | null;
  phoneNumber?: PatchOfString | null;
  isActive?: PatchOfNullableBoolean | null;
}

export class SettingModel implements ISettingModel {
  settingId!: number;
  startInvoiceDate?: Date | null;
  invoiceDailyTime?: Date | null;
  defaultExchangeTargetCurrencyId?: number | null;
  defaultExchangeTargetCurrency?: CurrencyModel | null;

  constructor(data?: ISettingModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.settingId =
        _data["settingId"] !== undefined ? _data["settingId"] : <any>null;
      this.startInvoiceDate = _data["startInvoiceDate"]
        ? new Date(_data["startInvoiceDate"].toString())
        : <any>null;
      this.invoiceDailyTime = _data["invoiceDailyTime"]
        ? new Date(_data["invoiceDailyTime"].toString())
        : <any>null;
      this.defaultExchangeTargetCurrencyId =
        _data["defaultExchangeTargetCurrencyId"] !== undefined
          ? _data["defaultExchangeTargetCurrencyId"]
          : <any>null;
      this.defaultExchangeTargetCurrency = _data[
        "defaultExchangeTargetCurrency"
      ]
        ? CurrencyModel.fromJS(_data["defaultExchangeTargetCurrency"])
        : <any>null;
    }
  }

  static fromJS(data: any): SettingModel {
    data = typeof data === "object" ? data : {};
    let result = new SettingModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["settingId"] =
      this.settingId !== undefined ? this.settingId : <any>null;
    data["startInvoiceDate"] = this.startInvoiceDate
      ? this.startInvoiceDate.toISOString()
      : <any>null;
    data["invoiceDailyTime"] = this.invoiceDailyTime
      ? this.invoiceDailyTime.toISOString()
      : <any>null;
    data["defaultExchangeTargetCurrencyId"] =
      this.defaultExchangeTargetCurrencyId !== undefined
        ? this.defaultExchangeTargetCurrencyId
        : <any>null;
    data["defaultExchangeTargetCurrency"] = this.defaultExchangeTargetCurrency
      ? this.defaultExchangeTargetCurrency.toJSON()
      : <any>null;
    return data;
  }
}

export interface ISettingModel {
  settingId: number;
  startInvoiceDate?: Date | null;
  invoiceDailyTime?: Date | null;
  defaultExchangeTargetCurrencyId?: number | null;
  defaultExchangeTargetCurrency?: CurrencyModel | null;
}

export class CurrencyModel implements ICurrencyModel {
  currencyId!: number;
  currencyName!: string;
  isForTest!: boolean;
  payments?: PaymentOrderModel[] | null;
  ordinaryOrders?: OrdinaryOrderModel[] | null;
  currencyLimits?: MerchantCurrencyLimitModel[] | null;
  paymentProfiles?: PaymentProfileModel[] | null;

  constructor(data?: ICurrencyModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.currencyName =
        _data["currencyName"] !== undefined ? _data["currencyName"] : <any>null;
      this.isForTest =
        _data["isForTest"] !== undefined ? _data["isForTest"] : <any>null;
      if (Array.isArray(_data["payments"])) {
        this.payments = [] as any;
        for (let item of _data["payments"])
          this.payments!.push(PaymentOrderModel.fromJS(item));
      } else {
        this.payments = <any>null;
      }
      if (Array.isArray(_data["ordinaryOrders"])) {
        this.ordinaryOrders = [] as any;
        for (let item of _data["ordinaryOrders"])
          this.ordinaryOrders!.push(OrdinaryOrderModel.fromJS(item));
      } else {
        this.ordinaryOrders = <any>null;
      }
      if (Array.isArray(_data["currencyLimits"])) {
        this.currencyLimits = [] as any;
        for (let item of _data["currencyLimits"])
          this.currencyLimits!.push(MerchantCurrencyLimitModel.fromJS(item));
      } else {
        this.currencyLimits = <any>null;
      }
      if (Array.isArray(_data["paymentProfiles"])) {
        this.paymentProfiles = [] as any;
        for (let item of _data["paymentProfiles"])
          this.paymentProfiles!.push(PaymentProfileModel.fromJS(item));
      } else {
        this.paymentProfiles = <any>null;
      }
    }
  }

  static fromJS(data: any): CurrencyModel {
    data = typeof data === "object" ? data : {};
    let result = new CurrencyModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["currencyName"] =
      this.currencyName !== undefined ? this.currencyName : <any>null;
    data["isForTest"] =
      this.isForTest !== undefined ? this.isForTest : <any>null;
    if (Array.isArray(this.payments)) {
      data["payments"] = [];
      for (let item of this.payments) data["payments"].push(item.toJSON());
    }
    if (Array.isArray(this.ordinaryOrders)) {
      data["ordinaryOrders"] = [];
      for (let item of this.ordinaryOrders)
        data["ordinaryOrders"].push(item.toJSON());
    }
    if (Array.isArray(this.currencyLimits)) {
      data["currencyLimits"] = [];
      for (let item of this.currencyLimits)
        data["currencyLimits"].push(item.toJSON());
    }
    if (Array.isArray(this.paymentProfiles)) {
      data["paymentProfiles"] = [];
      for (let item of this.paymentProfiles)
        data["paymentProfiles"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICurrencyModel {
  currencyId: number;
  currencyName: string;
  isForTest: boolean;
  payments?: PaymentOrderModel[] | null;
  ordinaryOrders?: OrdinaryOrderModel[] | null;
  currencyLimits?: MerchantCurrencyLimitModel[] | null;
  paymentProfiles?: PaymentProfileModel[] | null;
}

export class PaymentOrderModel implements IPaymentOrderModel {
  paymentOrderId!: number;
  providerPaymentId?: number | null;
  amount!: number;
  currencyId!: number;
  lastError?: string | null;
  merchantId!: number;
  createdTime!: Date;
  modifiedTime!: Date;
  paymentOrderState!: PaymentOrderState;
  captureWalletOrderReferenceNumber?: string | null;
  disputeWalletOrderReferenceNumber?: string | null;
  merchant?: MerchantModel | null;
  currency?: CurrencyModel | null;
  paymentOrderStateLogs?: PaymentOrderStateLogModel[] | null;

  constructor(data?: IPaymentOrderModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentOrderId =
        _data["paymentOrderId"] !== undefined
          ? _data["paymentOrderId"]
          : <any>null;
      this.providerPaymentId =
        _data["providerPaymentId"] !== undefined
          ? _data["providerPaymentId"]
          : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.lastError =
        _data["lastError"] !== undefined ? _data["lastError"] : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
      this.paymentOrderState =
        _data["paymentOrderState"] !== undefined
          ? _data["paymentOrderState"]
          : <any>null;
      this.captureWalletOrderReferenceNumber =
        _data["captureWalletOrderReferenceNumber"] !== undefined
          ? _data["captureWalletOrderReferenceNumber"]
          : <any>null;
      this.disputeWalletOrderReferenceNumber =
        _data["disputeWalletOrderReferenceNumber"] !== undefined
          ? _data["disputeWalletOrderReferenceNumber"]
          : <any>null;
      this.merchant = _data["merchant"]
        ? MerchantModel.fromJS(_data["merchant"])
        : <any>null;
      this.currency = _data["currency"]
        ? CurrencyModel.fromJS(_data["currency"])
        : <any>null;
      if (Array.isArray(_data["paymentOrderStateLogs"])) {
        this.paymentOrderStateLogs = [] as any;
        for (let item of _data["paymentOrderStateLogs"])
          this.paymentOrderStateLogs!.push(
            PaymentOrderStateLogModel.fromJS(item)
          );
      } else {
        this.paymentOrderStateLogs = <any>null;
      }
    }
  }

  static fromJS(data: any): PaymentOrderModel {
    data = typeof data === "object" ? data : {};
    let result = new PaymentOrderModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["paymentOrderId"] =
      this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
    data["providerPaymentId"] =
      this.providerPaymentId !== undefined ? this.providerPaymentId : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["lastError"] =
      this.lastError !== undefined ? this.lastError : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    data["paymentOrderState"] =
      this.paymentOrderState !== undefined ? this.paymentOrderState : <any>null;
    data["captureWalletOrderReferenceNumber"] =
      this.captureWalletOrderReferenceNumber !== undefined
        ? this.captureWalletOrderReferenceNumber
        : <any>null;
    data["disputeWalletOrderReferenceNumber"] =
      this.disputeWalletOrderReferenceNumber !== undefined
        ? this.disputeWalletOrderReferenceNumber
        : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    if (Array.isArray(this.paymentOrderStateLogs)) {
      data["paymentOrderStateLogs"] = [];
      for (let item of this.paymentOrderStateLogs)
        data["paymentOrderStateLogs"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaymentOrderModel {
  paymentOrderId: number;
  providerPaymentId?: number | null;
  amount: number;
  currencyId: number;
  lastError?: string | null;
  merchantId: number;
  createdTime: Date;
  modifiedTime: Date;
  paymentOrderState: PaymentOrderState;
  captureWalletOrderReferenceNumber?: string | null;
  disputeWalletOrderReferenceNumber?: string | null;
  merchant?: MerchantModel | null;
  currency?: CurrencyModel | null;
  paymentOrderStateLogs?: PaymentOrderStateLogModel[] | null;
}

export class MerchantModel implements IMerchantModel {
  merchantId!: number;
  merchantName!: string;
  parentBranchId?: number | null;
  saleManagerId?: number | null;
  rootBranchId?: number | null;
  description?: string | null;
  email!: string;
  isActive!: boolean;
  externalReference!: string;
  walletId!: number;
  creditWalletId?: number | null;
  invoiceThresholdDay?: number | null;
  website?: string | null;
  phoneNumberCountryCode?: string | null;
  phoneNumber?: string | null;
  whatsappNumberCountryCode?: string | null;
  whatsappNumber?: string | null;
  exchangeTargetCurrencyId!: number;
  assignedGatewayListId?: number | null;
  financialActivitiesTwoPhaseVerification!: boolean;
  timeZone?: string | null;
  createdTime!: Date;
  modifiedTime!: Date;
  address?: MerchantAddressModel | null;
  exchangeTargetCurrency?: CurrencyModel | null;
  rootBranch?: BranchModel | null;
  saleManager?: SaleManagerModel | null;
  merchantCredits?: CreditWalletModel[] | null;
  customerMerchantCredits?: CreditWalletModel[] | null;
  senderMerchantSettleOrders?: SettleOrderModel[] | null;
  receiverMerchantSettleOrders?: SettleOrderModel[] | null;
  payments?: PaymentOrderModel[] | null;
  senderMerchantOrdinaryOrders?: OrdinaryOrderModel[] | null;
  receiverMerchantOrdinaryOrders?: OrdinaryOrderModel[] | null;
  invoices?: InvoiceModel[] | null;
  currencyLimits?: MerchantCurrencyLimitModel[] | null;

  constructor(data?: IMerchantModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.merchantName =
        _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
      this.parentBranchId =
        _data["parentBranchId"] !== undefined
          ? _data["parentBranchId"]
          : <any>null;
      this.saleManagerId =
        _data["saleManagerId"] !== undefined
          ? _data["saleManagerId"]
          : <any>null;
      this.rootBranchId =
        _data["rootBranchId"] !== undefined ? _data["rootBranchId"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.externalReference =
        _data["externalReference"] !== undefined
          ? _data["externalReference"]
          : <any>null;
      this.walletId =
        _data["walletId"] !== undefined ? _data["walletId"] : <any>null;
      this.creditWalletId =
        _data["creditWalletId"] !== undefined
          ? _data["creditWalletId"]
          : <any>null;
      this.invoiceThresholdDay =
        _data["invoiceThresholdDay"] !== undefined
          ? _data["invoiceThresholdDay"]
          : <any>null;
      this.website =
        _data["website"] !== undefined ? _data["website"] : <any>null;
      this.phoneNumberCountryCode =
        _data["phoneNumberCountryCode"] !== undefined
          ? _data["phoneNumberCountryCode"]
          : <any>null;
      this.phoneNumber =
        _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
      this.whatsappNumberCountryCode =
        _data["whatsappNumberCountryCode"] !== undefined
          ? _data["whatsappNumberCountryCode"]
          : <any>null;
      this.whatsappNumber =
        _data["whatsappNumber"] !== undefined
          ? _data["whatsappNumber"]
          : <any>null;
      this.exchangeTargetCurrencyId =
        _data["exchangeTargetCurrencyId"] !== undefined
          ? _data["exchangeTargetCurrencyId"]
          : <any>null;
      this.assignedGatewayListId =
        _data["assignedGatewayListId"] !== undefined
          ? _data["assignedGatewayListId"]
          : <any>null;
      this.financialActivitiesTwoPhaseVerification =
        _data["financialActivitiesTwoPhaseVerification"] !== undefined
          ? _data["financialActivitiesTwoPhaseVerification"]
          : <any>null;
      this.timeZone =
        _data["timeZone"] !== undefined ? _data["timeZone"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
      this.address = _data["address"]
        ? MerchantAddressModel.fromJS(_data["address"])
        : <any>null;
      this.exchangeTargetCurrency = _data["exchangeTargetCurrency"]
        ? CurrencyModel.fromJS(_data["exchangeTargetCurrency"])
        : <any>null;
      this.rootBranch = _data["rootBranch"]
        ? BranchModel.fromJS(_data["rootBranch"])
        : <any>null;
      this.saleManager = _data["saleManager"]
        ? SaleManagerModel.fromJS(_data["saleManager"])
        : <any>null;
      if (Array.isArray(_data["merchantCredits"])) {
        this.merchantCredits = [] as any;
        for (let item of _data["merchantCredits"])
          this.merchantCredits!.push(CreditWalletModel.fromJS(item));
      } else {
        this.merchantCredits = <any>null;
      }
      if (Array.isArray(_data["customerMerchantCredits"])) {
        this.customerMerchantCredits = [] as any;
        for (let item of _data["customerMerchantCredits"])
          this.customerMerchantCredits!.push(CreditWalletModel.fromJS(item));
      } else {
        this.customerMerchantCredits = <any>null;
      }
      if (Array.isArray(_data["senderMerchantSettleOrders"])) {
        this.senderMerchantSettleOrders = [] as any;
        for (let item of _data["senderMerchantSettleOrders"])
          this.senderMerchantSettleOrders!.push(SettleOrderModel.fromJS(item));
      } else {
        this.senderMerchantSettleOrders = <any>null;
      }
      if (Array.isArray(_data["receiverMerchantSettleOrders"])) {
        this.receiverMerchantSettleOrders = [] as any;
        for (let item of _data["receiverMerchantSettleOrders"])
          this.receiverMerchantSettleOrders!.push(
            SettleOrderModel.fromJS(item)
          );
      } else {
        this.receiverMerchantSettleOrders = <any>null;
      }
      if (Array.isArray(_data["payments"])) {
        this.payments = [] as any;
        for (let item of _data["payments"])
          this.payments!.push(PaymentOrderModel.fromJS(item));
      } else {
        this.payments = <any>null;
      }
      if (Array.isArray(_data["senderMerchantOrdinaryOrders"])) {
        this.senderMerchantOrdinaryOrders = [] as any;
        for (let item of _data["senderMerchantOrdinaryOrders"])
          this.senderMerchantOrdinaryOrders!.push(
            OrdinaryOrderModel.fromJS(item)
          );
      } else {
        this.senderMerchantOrdinaryOrders = <any>null;
      }
      if (Array.isArray(_data["receiverMerchantOrdinaryOrders"])) {
        this.receiverMerchantOrdinaryOrders = [] as any;
        for (let item of _data["receiverMerchantOrdinaryOrders"])
          this.receiverMerchantOrdinaryOrders!.push(
            OrdinaryOrderModel.fromJS(item)
          );
      } else {
        this.receiverMerchantOrdinaryOrders = <any>null;
      }
      if (Array.isArray(_data["invoices"])) {
        this.invoices = [] as any;
        for (let item of _data["invoices"])
          this.invoices!.push(InvoiceModel.fromJS(item));
      } else {
        this.invoices = <any>null;
      }
      if (Array.isArray(_data["currencyLimits"])) {
        this.currencyLimits = [] as any;
        for (let item of _data["currencyLimits"])
          this.currencyLimits!.push(MerchantCurrencyLimitModel.fromJS(item));
      } else {
        this.currencyLimits = <any>null;
      }
    }
  }

  static fromJS(data: any): MerchantModel {
    data = typeof data === "object" ? data : {};
    let result = new MerchantModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["merchantName"] =
      this.merchantName !== undefined ? this.merchantName : <any>null;
    data["parentBranchId"] =
      this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
    data["saleManagerId"] =
      this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
    data["rootBranchId"] =
      this.rootBranchId !== undefined ? this.rootBranchId : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["externalReference"] =
      this.externalReference !== undefined ? this.externalReference : <any>null;
    data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
    data["creditWalletId"] =
      this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
    data["invoiceThresholdDay"] =
      this.invoiceThresholdDay !== undefined
        ? this.invoiceThresholdDay
        : <any>null;
    data["website"] = this.website !== undefined ? this.website : <any>null;
    data["phoneNumberCountryCode"] =
      this.phoneNumberCountryCode !== undefined
        ? this.phoneNumberCountryCode
        : <any>null;
    data["phoneNumber"] =
      this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
    data["whatsappNumberCountryCode"] =
      this.whatsappNumberCountryCode !== undefined
        ? this.whatsappNumberCountryCode
        : <any>null;
    data["whatsappNumber"] =
      this.whatsappNumber !== undefined ? this.whatsappNumber : <any>null;
    data["exchangeTargetCurrencyId"] =
      this.exchangeTargetCurrencyId !== undefined
        ? this.exchangeTargetCurrencyId
        : <any>null;
    data["assignedGatewayListId"] =
      this.assignedGatewayListId !== undefined
        ? this.assignedGatewayListId
        : <any>null;
    data["financialActivitiesTwoPhaseVerification"] =
      this.financialActivitiesTwoPhaseVerification !== undefined
        ? this.financialActivitiesTwoPhaseVerification
        : <any>null;
    data["timeZone"] = this.timeZone !== undefined ? this.timeZone : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    data["address"] = this.address ? this.address.toJSON() : <any>null;
    data["exchangeTargetCurrency"] = this.exchangeTargetCurrency
      ? this.exchangeTargetCurrency.toJSON()
      : <any>null;
    data["rootBranch"] = this.rootBranch ? this.rootBranch.toJSON() : <any>null;
    data["saleManager"] = this.saleManager
      ? this.saleManager.toJSON()
      : <any>null;
    if (Array.isArray(this.merchantCredits)) {
      data["merchantCredits"] = [];
      for (let item of this.merchantCredits)
        data["merchantCredits"].push(item.toJSON());
    }
    if (Array.isArray(this.customerMerchantCredits)) {
      data["customerMerchantCredits"] = [];
      for (let item of this.customerMerchantCredits)
        data["customerMerchantCredits"].push(item.toJSON());
    }
    if (Array.isArray(this.senderMerchantSettleOrders)) {
      data["senderMerchantSettleOrders"] = [];
      for (let item of this.senderMerchantSettleOrders)
        data["senderMerchantSettleOrders"].push(item.toJSON());
    }
    if (Array.isArray(this.receiverMerchantSettleOrders)) {
      data["receiverMerchantSettleOrders"] = [];
      for (let item of this.receiverMerchantSettleOrders)
        data["receiverMerchantSettleOrders"].push(item.toJSON());
    }
    if (Array.isArray(this.payments)) {
      data["payments"] = [];
      for (let item of this.payments) data["payments"].push(item.toJSON());
    }
    if (Array.isArray(this.senderMerchantOrdinaryOrders)) {
      data["senderMerchantOrdinaryOrders"] = [];
      for (let item of this.senderMerchantOrdinaryOrders)
        data["senderMerchantOrdinaryOrders"].push(item.toJSON());
    }
    if (Array.isArray(this.receiverMerchantOrdinaryOrders)) {
      data["receiverMerchantOrdinaryOrders"] = [];
      for (let item of this.receiverMerchantOrdinaryOrders)
        data["receiverMerchantOrdinaryOrders"].push(item.toJSON());
    }
    if (Array.isArray(this.invoices)) {
      data["invoices"] = [];
      for (let item of this.invoices) data["invoices"].push(item.toJSON());
    }
    if (Array.isArray(this.currencyLimits)) {
      data["currencyLimits"] = [];
      for (let item of this.currencyLimits)
        data["currencyLimits"].push(item.toJSON());
    }
    return data;
  }
}

export interface IMerchantModel {
  merchantId: number;
  merchantName: string;
  parentBranchId?: number | null;
  saleManagerId?: number | null;
  rootBranchId?: number | null;
  description?: string | null;
  email: string;
  isActive: boolean;
  externalReference: string;
  walletId: number;
  creditWalletId?: number | null;
  invoiceThresholdDay?: number | null;
  website?: string | null;
  phoneNumberCountryCode?: string | null;
  phoneNumber?: string | null;
  whatsappNumberCountryCode?: string | null;
  whatsappNumber?: string | null;
  exchangeTargetCurrencyId: number;
  assignedGatewayListId?: number | null;
  financialActivitiesTwoPhaseVerification: boolean;
  timeZone?: string | null;
  createdTime: Date;
  modifiedTime: Date;
  address?: MerchantAddressModel | null;
  exchangeTargetCurrency?: CurrencyModel | null;
  rootBranch?: BranchModel | null;
  saleManager?: SaleManagerModel | null;
  merchantCredits?: CreditWalletModel[] | null;
  customerMerchantCredits?: CreditWalletModel[] | null;
  senderMerchantSettleOrders?: SettleOrderModel[] | null;
  receiverMerchantSettleOrders?: SettleOrderModel[] | null;
  payments?: PaymentOrderModel[] | null;
  senderMerchantOrdinaryOrders?: OrdinaryOrderModel[] | null;
  receiverMerchantOrdinaryOrders?: OrdinaryOrderModel[] | null;
  invoices?: InvoiceModel[] | null;
  currencyLimits?: MerchantCurrencyLimitModel[] | null;
}

export class MerchantAddressModel implements IMerchantAddressModel {
  merchantId!: number;
  country?: string | null;
  state?: string | null;
  city?: string | null;
  rawAddress?: string | null;
  postalCode?: string | null;
  merchant?: MerchantModel | null;

  constructor(data?: IMerchantAddressModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.country =
        _data["country"] !== undefined ? _data["country"] : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
      this.rawAddress =
        _data["rawAddress"] !== undefined ? _data["rawAddress"] : <any>null;
      this.postalCode =
        _data["postalCode"] !== undefined ? _data["postalCode"] : <any>null;
      this.merchant = _data["merchant"]
        ? MerchantModel.fromJS(_data["merchant"])
        : <any>null;
    }
  }

  static fromJS(data: any): MerchantAddressModel {
    data = typeof data === "object" ? data : {};
    let result = new MerchantAddressModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["country"] = this.country !== undefined ? this.country : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["city"] = this.city !== undefined ? this.city : <any>null;
    data["rawAddress"] =
      this.rawAddress !== undefined ? this.rawAddress : <any>null;
    data["postalCode"] =
      this.postalCode !== undefined ? this.postalCode : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    return data;
  }
}

export interface IMerchantAddressModel {
  merchantId: number;
  country?: string | null;
  state?: string | null;
  city?: string | null;
  rawAddress?: string | null;
  postalCode?: string | null;
  merchant?: MerchantModel | null;
}

export class BranchModel implements IBranchModel {
  branchId!: number;
  branchName!: string;
  parentBranchId?: number | null;
  description?: string | null;
  isActive!: boolean;
  rootPriceListId?: number | null;
  merchantId!: number;
  canSetFaceValue!: boolean;
  canSetBuyValue!: boolean;
  canPlaceOrder!: boolean;
  canCreateGatewayList!: boolean;
  canCreatePaymentOrder!: boolean;
  calculateProfitByStockTotalBuyPrice!: boolean;
  createdTime!: Date;
  modifiedTime!: Date;
  subBranches?: BranchModel[] | null;
  saleManagers?: SaleManagerModel[] | null;
  merchant!: MerchantModel;
  parentBranch?: BranchModel | null;
  gatewayLists?: GatewayListModel[] | null;

  constructor(data?: IBranchModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.merchant = new MerchantModel();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.branchName =
        _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
      this.parentBranchId =
        _data["parentBranchId"] !== undefined
          ? _data["parentBranchId"]
          : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.rootPriceListId =
        _data["rootPriceListId"] !== undefined
          ? _data["rootPriceListId"]
          : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.canSetFaceValue =
        _data["canSetFaceValue"] !== undefined
          ? _data["canSetFaceValue"]
          : <any>null;
      this.canSetBuyValue =
        _data["canSetBuyValue"] !== undefined
          ? _data["canSetBuyValue"]
          : <any>null;
      this.canPlaceOrder =
        _data["canPlaceOrder"] !== undefined
          ? _data["canPlaceOrder"]
          : <any>null;
      this.canCreateGatewayList =
        _data["canCreateGatewayList"] !== undefined
          ? _data["canCreateGatewayList"]
          : <any>null;
      this.canCreatePaymentOrder =
        _data["canCreatePaymentOrder"] !== undefined
          ? _data["canCreatePaymentOrder"]
          : <any>null;
      this.calculateProfitByStockTotalBuyPrice =
        _data["calculateProfitByStockTotalBuyPrice"] !== undefined
          ? _data["calculateProfitByStockTotalBuyPrice"]
          : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
      if (Array.isArray(_data["subBranches"])) {
        this.subBranches = [] as any;
        for (let item of _data["subBranches"])
          this.subBranches!.push(BranchModel.fromJS(item));
      } else {
        this.subBranches = <any>null;
      }
      if (Array.isArray(_data["saleManagers"])) {
        this.saleManagers = [] as any;
        for (let item of _data["saleManagers"])
          this.saleManagers!.push(SaleManagerModel.fromJS(item));
      } else {
        this.saleManagers = <any>null;
      }
      this.merchant = _data["merchant"]
        ? MerchantModel.fromJS(_data["merchant"])
        : new MerchantModel();
      this.parentBranch = _data["parentBranch"]
        ? BranchModel.fromJS(_data["parentBranch"])
        : <any>null;
      if (Array.isArray(_data["gatewayLists"])) {
        this.gatewayLists = [] as any;
        for (let item of _data["gatewayLists"])
          this.gatewayLists!.push(GatewayListModel.fromJS(item));
      } else {
        this.gatewayLists = <any>null;
      }
    }
  }

  static fromJS(data: any): BranchModel {
    data = typeof data === "object" ? data : {};
    let result = new BranchModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["branchName"] =
      this.branchName !== undefined ? this.branchName : <any>null;
    data["parentBranchId"] =
      this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["rootPriceListId"] =
      this.rootPriceListId !== undefined ? this.rootPriceListId : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["canSetFaceValue"] =
      this.canSetFaceValue !== undefined ? this.canSetFaceValue : <any>null;
    data["canSetBuyValue"] =
      this.canSetBuyValue !== undefined ? this.canSetBuyValue : <any>null;
    data["canPlaceOrder"] =
      this.canPlaceOrder !== undefined ? this.canPlaceOrder : <any>null;
    data["canCreateGatewayList"] =
      this.canCreateGatewayList !== undefined
        ? this.canCreateGatewayList
        : <any>null;
    data["canCreatePaymentOrder"] =
      this.canCreatePaymentOrder !== undefined
        ? this.canCreatePaymentOrder
        : <any>null;
    data["calculateProfitByStockTotalBuyPrice"] =
      this.calculateProfitByStockTotalBuyPrice !== undefined
        ? this.calculateProfitByStockTotalBuyPrice
        : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    if (Array.isArray(this.subBranches)) {
      data["subBranches"] = [];
      for (let item of this.subBranches)
        data["subBranches"].push(item.toJSON());
    }
    if (Array.isArray(this.saleManagers)) {
      data["saleManagers"] = [];
      for (let item of this.saleManagers)
        data["saleManagers"].push(item.toJSON());
    }
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    data["parentBranch"] = this.parentBranch
      ? this.parentBranch.toJSON()
      : <any>null;
    if (Array.isArray(this.gatewayLists)) {
      data["gatewayLists"] = [];
      for (let item of this.gatewayLists)
        data["gatewayLists"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBranchModel {
  branchId: number;
  branchName: string;
  parentBranchId?: number | null;
  description?: string | null;
  isActive: boolean;
  rootPriceListId?: number | null;
  merchantId: number;
  canSetFaceValue: boolean;
  canSetBuyValue: boolean;
  canPlaceOrder: boolean;
  canCreateGatewayList: boolean;
  canCreatePaymentOrder: boolean;
  calculateProfitByStockTotalBuyPrice: boolean;
  createdTime: Date;
  modifiedTime: Date;
  subBranches?: BranchModel[] | null;
  saleManagers?: SaleManagerModel[] | null;
  merchant: MerchantModel;
  parentBranch?: BranchModel | null;
  gatewayLists?: GatewayListModel[] | null;
}

export class SaleManagerModel implements ISaleManagerModel {
  saleManagerId!: number;
  userId!: string;
  name!: string;
  email!: string;
  phoneNumber?: string | null;
  isActive!: boolean;
  branchId!: number;
  createdTime!: Date;
  modifiedTime!: Date;
  branch?: BranchModel | null;
  customers?: MerchantModel[] | null;

  constructor(data?: ISaleManagerModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.saleManagerId =
        _data["saleManagerId"] !== undefined
          ? _data["saleManagerId"]
          : <any>null;
      this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.phoneNumber =
        _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
      this.branch = _data["branch"]
        ? BranchModel.fromJS(_data["branch"])
        : <any>null;
      if (Array.isArray(_data["customers"])) {
        this.customers = [] as any;
        for (let item of _data["customers"])
          this.customers!.push(MerchantModel.fromJS(item));
      } else {
        this.customers = <any>null;
      }
    }
  }

  static fromJS(data: any): SaleManagerModel {
    data = typeof data === "object" ? data : {};
    let result = new SaleManagerModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["saleManagerId"] =
      this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
    data["userId"] = this.userId !== undefined ? this.userId : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["phoneNumber"] =
      this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    data["branch"] = this.branch ? this.branch.toJSON() : <any>null;
    if (Array.isArray(this.customers)) {
      data["customers"] = [];
      for (let item of this.customers) data["customers"].push(item.toJSON());
    }
    return data;
  }
}

export interface ISaleManagerModel {
  saleManagerId: number;
  userId: string;
  name: string;
  email: string;
  phoneNumber?: string | null;
  isActive: boolean;
  branchId: number;
  createdTime: Date;
  modifiedTime: Date;
  branch?: BranchModel | null;
  customers?: MerchantModel[] | null;
}

export class GatewayListModel implements IGatewayListModel {
  gatewayListId!: number;
  name!: string;
  branchId!: number;
  createdTime!: Date;
  modifiedTime!: Date;
  branch?: BranchModel | null;
  paymentProfiles?: GatewayListPaymentProfileModel[] | null;

  constructor(data?: IGatewayListModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.gatewayListId =
        _data["gatewayListId"] !== undefined
          ? _data["gatewayListId"]
          : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
      this.branch = _data["branch"]
        ? BranchModel.fromJS(_data["branch"])
        : <any>null;
      if (Array.isArray(_data["paymentProfiles"])) {
        this.paymentProfiles = [] as any;
        for (let item of _data["paymentProfiles"])
          this.paymentProfiles!.push(
            GatewayListPaymentProfileModel.fromJS(item)
          );
      } else {
        this.paymentProfiles = <any>null;
      }
    }
  }

  static fromJS(data: any): GatewayListModel {
    data = typeof data === "object" ? data : {};
    let result = new GatewayListModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["gatewayListId"] =
      this.gatewayListId !== undefined ? this.gatewayListId : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    data["branch"] = this.branch ? this.branch.toJSON() : <any>null;
    if (Array.isArray(this.paymentProfiles)) {
      data["paymentProfiles"] = [];
      for (let item of this.paymentProfiles)
        data["paymentProfiles"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGatewayListModel {
  gatewayListId: number;
  name: string;
  branchId: number;
  createdTime: Date;
  modifiedTime: Date;
  branch?: BranchModel | null;
  paymentProfiles?: GatewayListPaymentProfileModel[] | null;
}

export class GatewayListPaymentProfileModel
  implements IGatewayListPaymentProfileModel
{
  gatewayListPaymentProfileId!: number;
  gatewayListId!: number;
  paymentProfileId!: number;
  useForSubMerchants!: boolean;
  gatewayList?: GatewayListModel | null;
  paymentProfile?: PaymentProfileModel | null;

  constructor(data?: IGatewayListPaymentProfileModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.gatewayListPaymentProfileId =
        _data["gatewayListPaymentProfileId"] !== undefined
          ? _data["gatewayListPaymentProfileId"]
          : <any>null;
      this.gatewayListId =
        _data["gatewayListId"] !== undefined
          ? _data["gatewayListId"]
          : <any>null;
      this.paymentProfileId =
        _data["paymentProfileId"] !== undefined
          ? _data["paymentProfileId"]
          : <any>null;
      this.useForSubMerchants =
        _data["useForSubMerchants"] !== undefined
          ? _data["useForSubMerchants"]
          : <any>null;
      this.gatewayList = _data["gatewayList"]
        ? GatewayListModel.fromJS(_data["gatewayList"])
        : <any>null;
      this.paymentProfile = _data["paymentProfile"]
        ? PaymentProfileModel.fromJS(_data["paymentProfile"])
        : <any>null;
    }
  }

  static fromJS(data: any): GatewayListPaymentProfileModel {
    data = typeof data === "object" ? data : {};
    let result = new GatewayListPaymentProfileModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["gatewayListPaymentProfileId"] =
      this.gatewayListPaymentProfileId !== undefined
        ? this.gatewayListPaymentProfileId
        : <any>null;
    data["gatewayListId"] =
      this.gatewayListId !== undefined ? this.gatewayListId : <any>null;
    data["paymentProfileId"] =
      this.paymentProfileId !== undefined ? this.paymentProfileId : <any>null;
    data["useForSubMerchants"] =
      this.useForSubMerchants !== undefined
        ? this.useForSubMerchants
        : <any>null;
    data["gatewayList"] = this.gatewayList
      ? this.gatewayList.toJSON()
      : <any>null;
    data["paymentProfile"] = this.paymentProfile
      ? this.paymentProfile.toJSON()
      : <any>null;
    return data;
  }
}

export interface IGatewayListPaymentProfileModel {
  gatewayListPaymentProfileId: number;
  gatewayListId: number;
  paymentProfileId: number;
  useForSubMerchants: boolean;
  gatewayList?: GatewayListModel | null;
  paymentProfile?: PaymentProfileModel | null;
}

export class PaymentProfileModel implements IPaymentProfileModel {
  paymentProfileId!: number;
  providerProfileId!: number;
  description!: string;
  name!: string;
  minAmount!: number;
  maxAmount!: number;
  type!: PaymentProfileType;
  imageUri1!: string;
  imageUri2!: string;
  createdTime!: Date;
  modifiedTime!: Date;
  currencyId!: number;
  currency?: CurrencyModel | null;
  gatewayListPaymentProfiles?: GatewayListPaymentProfileModel[] | null;

  constructor(data?: IPaymentProfileModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentProfileId =
        _data["paymentProfileId"] !== undefined
          ? _data["paymentProfileId"]
          : <any>null;
      this.providerProfileId =
        _data["providerProfileId"] !== undefined
          ? _data["providerProfileId"]
          : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.minAmount =
        _data["minAmount"] !== undefined ? _data["minAmount"] : <any>null;
      this.maxAmount =
        _data["maxAmount"] !== undefined ? _data["maxAmount"] : <any>null;
      this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
      this.imageUri1 =
        _data["imageUri1"] !== undefined ? _data["imageUri1"] : <any>null;
      this.imageUri2 =
        _data["imageUri2"] !== undefined ? _data["imageUri2"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.currency = _data["currency"]
        ? CurrencyModel.fromJS(_data["currency"])
        : <any>null;
      if (Array.isArray(_data["gatewayListPaymentProfiles"])) {
        this.gatewayListPaymentProfiles = [] as any;
        for (let item of _data["gatewayListPaymentProfiles"])
          this.gatewayListPaymentProfiles!.push(
            GatewayListPaymentProfileModel.fromJS(item)
          );
      } else {
        this.gatewayListPaymentProfiles = <any>null;
      }
    }
  }

  static fromJS(data: any): PaymentProfileModel {
    data = typeof data === "object" ? data : {};
    let result = new PaymentProfileModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["paymentProfileId"] =
      this.paymentProfileId !== undefined ? this.paymentProfileId : <any>null;
    data["providerProfileId"] =
      this.providerProfileId !== undefined ? this.providerProfileId : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["minAmount"] =
      this.minAmount !== undefined ? this.minAmount : <any>null;
    data["maxAmount"] =
      this.maxAmount !== undefined ? this.maxAmount : <any>null;
    data["type"] = this.type !== undefined ? this.type : <any>null;
    data["imageUri1"] =
      this.imageUri1 !== undefined ? this.imageUri1 : <any>null;
    data["imageUri2"] =
      this.imageUri2 !== undefined ? this.imageUri2 : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    if (Array.isArray(this.gatewayListPaymentProfiles)) {
      data["gatewayListPaymentProfiles"] = [];
      for (let item of this.gatewayListPaymentProfiles)
        data["gatewayListPaymentProfiles"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaymentProfileModel {
  paymentProfileId: number;
  providerProfileId: number;
  description: string;
  name: string;
  minAmount: number;
  maxAmount: number;
  type: PaymentProfileType;
  imageUri1: string;
  imageUri2: string;
  createdTime: Date;
  modifiedTime: Date;
  currencyId: number;
  currency?: CurrencyModel | null;
  gatewayListPaymentProfiles?: GatewayListPaymentProfileModel[] | null;
}

export enum PaymentProfileType {
  PaymentProvider = "PaymentProvider",
}

export class CreditWalletModel implements ICreditWalletModel {
  creditWalletId!: number;
  merchantId!: number;
  merchantCreditWalletId?: number | null;
  customerMerchantId!: number;
  customerMerchantCreditWalletId?: number | null;
  merchant?: MerchantModel | null;
  customerMerchant?: MerchantModel | null;
  walletOrders?: CreditOrderModel[] | null;

  constructor(data?: ICreditWalletModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.creditWalletId =
        _data["creditWalletId"] !== undefined
          ? _data["creditWalletId"]
          : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.merchantCreditWalletId =
        _data["merchantCreditWalletId"] !== undefined
          ? _data["merchantCreditWalletId"]
          : <any>null;
      this.customerMerchantId =
        _data["customerMerchantId"] !== undefined
          ? _data["customerMerchantId"]
          : <any>null;
      this.customerMerchantCreditWalletId =
        _data["customerMerchantCreditWalletId"] !== undefined
          ? _data["customerMerchantCreditWalletId"]
          : <any>null;
      this.merchant = _data["merchant"]
        ? MerchantModel.fromJS(_data["merchant"])
        : <any>null;
      this.customerMerchant = _data["customerMerchant"]
        ? MerchantModel.fromJS(_data["customerMerchant"])
        : <any>null;
      if (Array.isArray(_data["walletOrders"])) {
        this.walletOrders = [] as any;
        for (let item of _data["walletOrders"])
          this.walletOrders!.push(CreditOrderModel.fromJS(item));
      } else {
        this.walletOrders = <any>null;
      }
    }
  }

  static fromJS(data: any): CreditWalletModel {
    data = typeof data === "object" ? data : {};
    let result = new CreditWalletModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["creditWalletId"] =
      this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["merchantCreditWalletId"] =
      this.merchantCreditWalletId !== undefined
        ? this.merchantCreditWalletId
        : <any>null;
    data["customerMerchantId"] =
      this.customerMerchantId !== undefined
        ? this.customerMerchantId
        : <any>null;
    data["customerMerchantCreditWalletId"] =
      this.customerMerchantCreditWalletId !== undefined
        ? this.customerMerchantCreditWalletId
        : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    data["customerMerchant"] = this.customerMerchant
      ? this.customerMerchant.toJSON()
      : <any>null;
    if (Array.isArray(this.walletOrders)) {
      data["walletOrders"] = [];
      for (let item of this.walletOrders)
        data["walletOrders"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICreditWalletModel {
  creditWalletId: number;
  merchantId: number;
  merchantCreditWalletId?: number | null;
  customerMerchantId: number;
  customerMerchantCreditWalletId?: number | null;
  merchant?: MerchantModel | null;
  customerMerchant?: MerchantModel | null;
  walletOrders?: CreditOrderModel[] | null;
}

export class CreditOrderModel implements ICreditOrderModel {
  creditOrderId!: number;
  mainWalletOrderId!: string;
  creditWalletOrderId!: string;
  state!: CreditOrderState;
  error?: string | null;
  description!: string;
  creditWalletId!: number;
  currencyId!: number;
  amount!: number;
  firstVerifierUserId?: string | null;
  secondVerifierUserId?: string | null;
  createdByUserId!: string;
  createdTime!: Date;
  modifiedTime!: Date;
  currency?: CurrencyModel | null;
  creditWallet?: CreditWalletModel | null;
  creditOrderStateLogs?: CreditOrderStateLogModel[] | null;

  constructor(data?: ICreditOrderModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.creditOrderId =
        _data["creditOrderId"] !== undefined
          ? _data["creditOrderId"]
          : <any>null;
      this.mainWalletOrderId =
        _data["mainWalletOrderId"] !== undefined
          ? _data["mainWalletOrderId"]
          : <any>null;
      this.creditWalletOrderId =
        _data["creditWalletOrderId"] !== undefined
          ? _data["creditWalletOrderId"]
          : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.creditWalletId =
        _data["creditWalletId"] !== undefined
          ? _data["creditWalletId"]
          : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.firstVerifierUserId =
        _data["firstVerifierUserId"] !== undefined
          ? _data["firstVerifierUserId"]
          : <any>null;
      this.secondVerifierUserId =
        _data["secondVerifierUserId"] !== undefined
          ? _data["secondVerifierUserId"]
          : <any>null;
      this.createdByUserId =
        _data["createdByUserId"] !== undefined
          ? _data["createdByUserId"]
          : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
      this.currency = _data["currency"]
        ? CurrencyModel.fromJS(_data["currency"])
        : <any>null;
      this.creditWallet = _data["creditWallet"]
        ? CreditWalletModel.fromJS(_data["creditWallet"])
        : <any>null;
      if (Array.isArray(_data["creditOrderStateLogs"])) {
        this.creditOrderStateLogs = [] as any;
        for (let item of _data["creditOrderStateLogs"])
          this.creditOrderStateLogs!.push(
            CreditOrderStateLogModel.fromJS(item)
          );
      } else {
        this.creditOrderStateLogs = <any>null;
      }
    }
  }

  static fromJS(data: any): CreditOrderModel {
    data = typeof data === "object" ? data : {};
    let result = new CreditOrderModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["creditOrderId"] =
      this.creditOrderId !== undefined ? this.creditOrderId : <any>null;
    data["mainWalletOrderId"] =
      this.mainWalletOrderId !== undefined ? this.mainWalletOrderId : <any>null;
    data["creditWalletOrderId"] =
      this.creditWalletOrderId !== undefined
        ? this.creditWalletOrderId
        : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["error"] = this.error !== undefined ? this.error : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["creditWalletId"] =
      this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["firstVerifierUserId"] =
      this.firstVerifierUserId !== undefined
        ? this.firstVerifierUserId
        : <any>null;
    data["secondVerifierUserId"] =
      this.secondVerifierUserId !== undefined
        ? this.secondVerifierUserId
        : <any>null;
    data["createdByUserId"] =
      this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["creditWallet"] = this.creditWallet
      ? this.creditWallet.toJSON()
      : <any>null;
    if (Array.isArray(this.creditOrderStateLogs)) {
      data["creditOrderStateLogs"] = [];
      for (let item of this.creditOrderStateLogs)
        data["creditOrderStateLogs"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICreditOrderModel {
  creditOrderId: number;
  mainWalletOrderId: string;
  creditWalletOrderId: string;
  state: CreditOrderState;
  error?: string | null;
  description: string;
  creditWalletId: number;
  currencyId: number;
  amount: number;
  firstVerifierUserId?: string | null;
  secondVerifierUserId?: string | null;
  createdByUserId: string;
  createdTime: Date;
  modifiedTime: Date;
  currency?: CurrencyModel | null;
  creditWallet?: CreditWalletModel | null;
  creditOrderStateLogs?: CreditOrderStateLogModel[] | null;
}

export enum CreditOrderState {
  Created = 0,
  AuthMainWallet = 1,
  SettingMinBalance = 2,
  Fail = 4,
  Success = 5,
  CaptureMainWallet = 6,
  Rejecting = 7,
  Verifying = 8,
  CapturingMainWallet = 9,
}

export class CreditOrderStateLogModel implements ICreditOrderStateLogModel {
  creditOrderStateLogId!: number;
  creditOrderId!: number;
  state!: CreditOrderState;
  reason?: string | null;
  createdTime!: Date;
  creditOrder?: CreditOrderModel | null;

  constructor(data?: ICreditOrderStateLogModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.creditOrderStateLogId =
        _data["creditOrderStateLogId"] !== undefined
          ? _data["creditOrderStateLogId"]
          : <any>null;
      this.creditOrderId =
        _data["creditOrderId"] !== undefined
          ? _data["creditOrderId"]
          : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.reason = _data["reason"] !== undefined ? _data["reason"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.creditOrder = _data["creditOrder"]
        ? CreditOrderModel.fromJS(_data["creditOrder"])
        : <any>null;
    }
  }

  static fromJS(data: any): CreditOrderStateLogModel {
    data = typeof data === "object" ? data : {};
    let result = new CreditOrderStateLogModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["creditOrderStateLogId"] =
      this.creditOrderStateLogId !== undefined
        ? this.creditOrderStateLogId
        : <any>null;
    data["creditOrderId"] =
      this.creditOrderId !== undefined ? this.creditOrderId : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["reason"] = this.reason !== undefined ? this.reason : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["creditOrder"] = this.creditOrder
      ? this.creditOrder.toJSON()
      : <any>null;
    return data;
  }
}

export interface ICreditOrderStateLogModel {
  creditOrderStateLogId: number;
  creditOrderId: number;
  state: CreditOrderState;
  reason?: string | null;
  createdTime: Date;
  creditOrder?: CreditOrderModel | null;
}

export class SettleOrderModel implements ISettleOrderModel {
  settleOrderId!: number;
  creditWalletOrderId!: string;
  mainWalletOrderId!: string;
  state!: SettleOrderState;
  reason?: string | null;
  description!: string;
  senderMerchantId!: number;
  senderMerchantCreditWalletId!: number;
  receiverMerchantId!: number;
  receiverMerchantCreditWalletId!: number;
  currencyId!: number;
  creditWalletId!: number;
  amount!: number;
  firstVerifierUserId?: string | null;
  secondVerifierUserId?: string | null;
  createdByUserId!: string;
  createdTime!: Date;
  modifiedTime!: Date;
  senderMerchant?: MerchantModel | null;
  receiverMerchant?: MerchantModel | null;
  currency?: CurrencyModel | null;
  creditWallet?: CreditWalletModel | null;
  settleOrderStateLogs?: SettleOrderStateLogModel[] | null;

  constructor(data?: ISettleOrderModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.settleOrderId =
        _data["settleOrderId"] !== undefined
          ? _data["settleOrderId"]
          : <any>null;
      this.creditWalletOrderId =
        _data["creditWalletOrderId"] !== undefined
          ? _data["creditWalletOrderId"]
          : <any>null;
      this.mainWalletOrderId =
        _data["mainWalletOrderId"] !== undefined
          ? _data["mainWalletOrderId"]
          : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.reason = _data["reason"] !== undefined ? _data["reason"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.senderMerchantId =
        _data["senderMerchantId"] !== undefined
          ? _data["senderMerchantId"]
          : <any>null;
      this.senderMerchantCreditWalletId =
        _data["senderMerchantCreditWalletId"] !== undefined
          ? _data["senderMerchantCreditWalletId"]
          : <any>null;
      this.receiverMerchantId =
        _data["receiverMerchantId"] !== undefined
          ? _data["receiverMerchantId"]
          : <any>null;
      this.receiverMerchantCreditWalletId =
        _data["receiverMerchantCreditWalletId"] !== undefined
          ? _data["receiverMerchantCreditWalletId"]
          : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.creditWalletId =
        _data["creditWalletId"] !== undefined
          ? _data["creditWalletId"]
          : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.firstVerifierUserId =
        _data["firstVerifierUserId"] !== undefined
          ? _data["firstVerifierUserId"]
          : <any>null;
      this.secondVerifierUserId =
        _data["secondVerifierUserId"] !== undefined
          ? _data["secondVerifierUserId"]
          : <any>null;
      this.createdByUserId =
        _data["createdByUserId"] !== undefined
          ? _data["createdByUserId"]
          : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
      this.senderMerchant = _data["senderMerchant"]
        ? MerchantModel.fromJS(_data["senderMerchant"])
        : <any>null;
      this.receiverMerchant = _data["receiverMerchant"]
        ? MerchantModel.fromJS(_data["receiverMerchant"])
        : <any>null;
      this.currency = _data["currency"]
        ? CurrencyModel.fromJS(_data["currency"])
        : <any>null;
      this.creditWallet = _data["creditWallet"]
        ? CreditWalletModel.fromJS(_data["creditWallet"])
        : <any>null;
      if (Array.isArray(_data["settleOrderStateLogs"])) {
        this.settleOrderStateLogs = [] as any;
        for (let item of _data["settleOrderStateLogs"])
          this.settleOrderStateLogs!.push(
            SettleOrderStateLogModel.fromJS(item)
          );
      } else {
        this.settleOrderStateLogs = <any>null;
      }
    }
  }

  static fromJS(data: any): SettleOrderModel {
    data = typeof data === "object" ? data : {};
    let result = new SettleOrderModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["settleOrderId"] =
      this.settleOrderId !== undefined ? this.settleOrderId : <any>null;
    data["creditWalletOrderId"] =
      this.creditWalletOrderId !== undefined
        ? this.creditWalletOrderId
        : <any>null;
    data["mainWalletOrderId"] =
      this.mainWalletOrderId !== undefined ? this.mainWalletOrderId : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["reason"] = this.reason !== undefined ? this.reason : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["senderMerchantId"] =
      this.senderMerchantId !== undefined ? this.senderMerchantId : <any>null;
    data["senderMerchantCreditWalletId"] =
      this.senderMerchantCreditWalletId !== undefined
        ? this.senderMerchantCreditWalletId
        : <any>null;
    data["receiverMerchantId"] =
      this.receiverMerchantId !== undefined
        ? this.receiverMerchantId
        : <any>null;
    data["receiverMerchantCreditWalletId"] =
      this.receiverMerchantCreditWalletId !== undefined
        ? this.receiverMerchantCreditWalletId
        : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["creditWalletId"] =
      this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["firstVerifierUserId"] =
      this.firstVerifierUserId !== undefined
        ? this.firstVerifierUserId
        : <any>null;
    data["secondVerifierUserId"] =
      this.secondVerifierUserId !== undefined
        ? this.secondVerifierUserId
        : <any>null;
    data["createdByUserId"] =
      this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    data["senderMerchant"] = this.senderMerchant
      ? this.senderMerchant.toJSON()
      : <any>null;
    data["receiverMerchant"] = this.receiverMerchant
      ? this.receiverMerchant.toJSON()
      : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["creditWallet"] = this.creditWallet
      ? this.creditWallet.toJSON()
      : <any>null;
    if (Array.isArray(this.settleOrderStateLogs)) {
      data["settleOrderStateLogs"] = [];
      for (let item of this.settleOrderStateLogs)
        data["settleOrderStateLogs"].push(item.toJSON());
    }
    return data;
  }
}

export interface ISettleOrderModel {
  settleOrderId: number;
  creditWalletOrderId: string;
  mainWalletOrderId: string;
  state: SettleOrderState;
  reason?: string | null;
  description: string;
  senderMerchantId: number;
  senderMerchantCreditWalletId: number;
  receiverMerchantId: number;
  receiverMerchantCreditWalletId: number;
  currencyId: number;
  creditWalletId: number;
  amount: number;
  firstVerifierUserId?: string | null;
  secondVerifierUserId?: string | null;
  createdByUserId: string;
  createdTime: Date;
  modifiedTime: Date;
  senderMerchant?: MerchantModel | null;
  receiverMerchant?: MerchantModel | null;
  currency?: CurrencyModel | null;
  creditWallet?: CreditWalletModel | null;
  settleOrderStateLogs?: SettleOrderStateLogModel[] | null;
}

export enum SettleOrderState {
  Created = 0,
  Fail = 1,
  Completed = 2,
  AuthCreditWallet = 3,
  AuthMainWallet = 4,
  CapturingWallets = 4,
  RollbackCreditAuthWallet = 6,
}

export class SettleOrderStateLogModel implements ISettleOrderStateLogModel {
  settleOrderStateLogId!: number;
  settleOrderId!: number;
  state!: SettleOrderState;
  error?: string | null;
  createdTime!: Date;
  settleOrder?: SettleOrderModel | null;

  constructor(data?: ISettleOrderStateLogModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.settleOrderStateLogId =
        _data["settleOrderStateLogId"] !== undefined
          ? _data["settleOrderStateLogId"]
          : <any>null;
      this.settleOrderId =
        _data["settleOrderId"] !== undefined
          ? _data["settleOrderId"]
          : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.settleOrder = _data["settleOrder"]
        ? SettleOrderModel.fromJS(_data["settleOrder"])
        : <any>null;
    }
  }

  static fromJS(data: any): SettleOrderStateLogModel {
    data = typeof data === "object" ? data : {};
    let result = new SettleOrderStateLogModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["settleOrderStateLogId"] =
      this.settleOrderStateLogId !== undefined
        ? this.settleOrderStateLogId
        : <any>null;
    data["settleOrderId"] =
      this.settleOrderId !== undefined ? this.settleOrderId : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["error"] = this.error !== undefined ? this.error : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["settleOrder"] = this.settleOrder
      ? this.settleOrder.toJSON()
      : <any>null;
    return data;
  }
}

export interface ISettleOrderStateLogModel {
  settleOrderStateLogId: number;
  settleOrderId: number;
  state: SettleOrderState;
  error?: string | null;
  createdTime: Date;
  settleOrder?: SettleOrderModel | null;
}

export class OrdinaryOrderModel implements IOrdinaryOrderModel {
  ordinaryOrderId!: number;
  walletOrderId!: string;
  state!: OrdinaryOrderState;
  ordinaryOrderType!: OrdinaryOrderType;
  reason?: string | null;
  description!: string;
  merchantId!: number;
  receiverMerchantId!: number;
  currencyId!: number;
  bankId?: number | null;
  amount!: number;
  firstVerifierUserId?: string | null;
  secondVerifierUserId?: string | null;
  createdByUserId!: string;
  createdTime!: Date;
  modifiedTime!: Date;
  modifiedByUserId!: string;
  currency?: CurrencyModel | null;
  merchant?: MerchantModel | null;
  receiverMerchant?: MerchantModel | null;
  bank?: BankModel | null;
  ordinaryOrderStateLogs?: OrdinaryOrderStateLogModel[] | null;

  constructor(data?: IOrdinaryOrderModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ordinaryOrderId =
        _data["ordinaryOrderId"] !== undefined
          ? _data["ordinaryOrderId"]
          : <any>null;
      this.walletOrderId =
        _data["walletOrderId"] !== undefined
          ? _data["walletOrderId"]
          : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.ordinaryOrderType =
        _data["ordinaryOrderType"] !== undefined
          ? _data["ordinaryOrderType"]
          : <any>null;
      this.reason = _data["reason"] !== undefined ? _data["reason"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.receiverMerchantId =
        _data["receiverMerchantId"] !== undefined
          ? _data["receiverMerchantId"]
          : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.bankId = _data["bankId"] !== undefined ? _data["bankId"] : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.firstVerifierUserId =
        _data["firstVerifierUserId"] !== undefined
          ? _data["firstVerifierUserId"]
          : <any>null;
      this.secondVerifierUserId =
        _data["secondVerifierUserId"] !== undefined
          ? _data["secondVerifierUserId"]
          : <any>null;
      this.createdByUserId =
        _data["createdByUserId"] !== undefined
          ? _data["createdByUserId"]
          : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
      this.modifiedByUserId =
        _data["modifiedByUserId"] !== undefined
          ? _data["modifiedByUserId"]
          : <any>null;
      this.currency = _data["currency"]
        ? CurrencyModel.fromJS(_data["currency"])
        : <any>null;
      this.merchant = _data["merchant"]
        ? MerchantModel.fromJS(_data["merchant"])
        : <any>null;
      this.receiverMerchant = _data["receiverMerchant"]
        ? MerchantModel.fromJS(_data["receiverMerchant"])
        : <any>null;
      this.bank = _data["bank"] ? BankModel.fromJS(_data["bank"]) : <any>null;
      if (Array.isArray(_data["ordinaryOrderStateLogs"])) {
        this.ordinaryOrderStateLogs = [] as any;
        for (let item of _data["ordinaryOrderStateLogs"])
          this.ordinaryOrderStateLogs!.push(
            OrdinaryOrderStateLogModel.fromJS(item)
          );
      } else {
        this.ordinaryOrderStateLogs = <any>null;
      }
    }
  }

  static fromJS(data: any): OrdinaryOrderModel {
    data = typeof data === "object" ? data : {};
    let result = new OrdinaryOrderModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ordinaryOrderId"] =
      this.ordinaryOrderId !== undefined ? this.ordinaryOrderId : <any>null;
    data["walletOrderId"] =
      this.walletOrderId !== undefined ? this.walletOrderId : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["ordinaryOrderType"] =
      this.ordinaryOrderType !== undefined ? this.ordinaryOrderType : <any>null;
    data["reason"] = this.reason !== undefined ? this.reason : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["receiverMerchantId"] =
      this.receiverMerchantId !== undefined
        ? this.receiverMerchantId
        : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["bankId"] = this.bankId !== undefined ? this.bankId : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["firstVerifierUserId"] =
      this.firstVerifierUserId !== undefined
        ? this.firstVerifierUserId
        : <any>null;
    data["secondVerifierUserId"] =
      this.secondVerifierUserId !== undefined
        ? this.secondVerifierUserId
        : <any>null;
    data["createdByUserId"] =
      this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    data["modifiedByUserId"] =
      this.modifiedByUserId !== undefined ? this.modifiedByUserId : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    data["receiverMerchant"] = this.receiverMerchant
      ? this.receiverMerchant.toJSON()
      : <any>null;
    data["bank"] = this.bank ? this.bank.toJSON() : <any>null;
    if (Array.isArray(this.ordinaryOrderStateLogs)) {
      data["ordinaryOrderStateLogs"] = [];
      for (let item of this.ordinaryOrderStateLogs)
        data["ordinaryOrderStateLogs"].push(item.toJSON());
    }
    return data;
  }
}

export interface IOrdinaryOrderModel {
  ordinaryOrderId: number;
  walletOrderId: string;
  state: OrdinaryOrderState;
  ordinaryOrderType: OrdinaryOrderType;
  reason?: string | null;
  description: string;
  merchantId: number;
  receiverMerchantId: number;
  currencyId: number;
  bankId?: number | null;
  amount: number;
  firstVerifierUserId?: string | null;
  secondVerifierUserId?: string | null;
  createdByUserId: string;
  createdTime: Date;
  modifiedTime: Date;
  modifiedByUserId: string;
  currency?: CurrencyModel | null;
  merchant?: MerchantModel | null;
  receiverMerchant?: MerchantModel | null;
  bank?: BankModel | null;
  ordinaryOrderStateLogs?: OrdinaryOrderStateLogModel[] | null;
}

export enum OrdinaryOrderState {
  Created = "Created",
  Success = "Success",
  Fail = "Fail",
  AuthWallet = "AuthWallet",
  Rejecting = "Rejecting",
  Verifying = "Verifying",
}

export enum OrdinaryOrderType {
  Charge = "Charge",
  Withdraw = "Withdraw",
  Rebate = "Rebate",
}

export class BankModel implements IBankModel {
  bankId!: number;
  bankName!: string;
  ordinaryOrders?: OrdinaryOrderModel[] | null;

  constructor(data?: IBankModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.bankId = _data["bankId"] !== undefined ? _data["bankId"] : <any>null;
      this.bankName =
        _data["bankName"] !== undefined ? _data["bankName"] : <any>null;
      if (Array.isArray(_data["ordinaryOrders"])) {
        this.ordinaryOrders = [] as any;
        for (let item of _data["ordinaryOrders"])
          this.ordinaryOrders!.push(OrdinaryOrderModel.fromJS(item));
      } else {
        this.ordinaryOrders = <any>null;
      }
    }
  }

  static fromJS(data: any): BankModel {
    data = typeof data === "object" ? data : {};
    let result = new BankModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["bankId"] = this.bankId !== undefined ? this.bankId : <any>null;
    data["bankName"] = this.bankName !== undefined ? this.bankName : <any>null;
    if (Array.isArray(this.ordinaryOrders)) {
      data["ordinaryOrders"] = [];
      for (let item of this.ordinaryOrders)
        data["ordinaryOrders"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBankModel {
  bankId: number;
  bankName: string;
  ordinaryOrders?: OrdinaryOrderModel[] | null;
}

export class OrdinaryOrderStateLogModel implements IOrdinaryOrderStateLogModel {
  ordinaryOrderStateLogId!: number;
  ordinaryOrderId!: number;
  state!: OrdinaryOrderState;
  error?: string | null;
  createdTime!: Date;
  ordinaryOrder?: OrdinaryOrderModel | null;

  constructor(data?: IOrdinaryOrderStateLogModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ordinaryOrderStateLogId =
        _data["ordinaryOrderStateLogId"] !== undefined
          ? _data["ordinaryOrderStateLogId"]
          : <any>null;
      this.ordinaryOrderId =
        _data["ordinaryOrderId"] !== undefined
          ? _data["ordinaryOrderId"]
          : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.ordinaryOrder = _data["ordinaryOrder"]
        ? OrdinaryOrderModel.fromJS(_data["ordinaryOrder"])
        : <any>null;
    }
  }

  static fromJS(data: any): OrdinaryOrderStateLogModel {
    data = typeof data === "object" ? data : {};
    let result = new OrdinaryOrderStateLogModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ordinaryOrderStateLogId"] =
      this.ordinaryOrderStateLogId !== undefined
        ? this.ordinaryOrderStateLogId
        : <any>null;
    data["ordinaryOrderId"] =
      this.ordinaryOrderId !== undefined ? this.ordinaryOrderId : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["error"] = this.error !== undefined ? this.error : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["ordinaryOrder"] = this.ordinaryOrder
      ? this.ordinaryOrder.toJSON()
      : <any>null;
    return data;
  }
}

export interface IOrdinaryOrderStateLogModel {
  ordinaryOrderStateLogId: number;
  ordinaryOrderId: number;
  state: OrdinaryOrderState;
  error?: string | null;
  createdTime: Date;
  ordinaryOrder?: OrdinaryOrderModel | null;
}

export class InvoiceModel implements IInvoiceModel {
  invoiceId!: number;
  merchantId!: number;
  createdTime!: Date;
  beginTime!: Date;
  endTime!: Date;
  merchant?: MerchantModel | null;
  invoiceDetails?: InvoiceDetailModel[] | null;

  constructor(data?: IInvoiceModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.invoiceId =
        _data["invoiceId"] !== undefined ? _data["invoiceId"] : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.beginTime = _data["beginTime"]
        ? new Date(_data["beginTime"].toString())
        : <any>null;
      this.endTime = _data["endTime"]
        ? new Date(_data["endTime"].toString())
        : <any>null;
      this.merchant = _data["merchant"]
        ? MerchantModel.fromJS(_data["merchant"])
        : <any>null;
      if (Array.isArray(_data["invoiceDetails"])) {
        this.invoiceDetails = [] as any;
        for (let item of _data["invoiceDetails"])
          this.invoiceDetails!.push(InvoiceDetailModel.fromJS(item));
      } else {
        this.invoiceDetails = <any>null;
      }
    }
  }

  static fromJS(data: any): InvoiceModel {
    data = typeof data === "object" ? data : {};
    let result = new InvoiceModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["invoiceId"] =
      this.invoiceId !== undefined ? this.invoiceId : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["beginTime"] = this.beginTime
      ? this.beginTime.toISOString()
      : <any>null;
    data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    if (Array.isArray(this.invoiceDetails)) {
      data["invoiceDetails"] = [];
      for (let item of this.invoiceDetails)
        data["invoiceDetails"].push(item.toJSON());
    }
    return data;
  }
}

export interface IInvoiceModel {
  invoiceId: number;
  merchantId: number;
  createdTime: Date;
  beginTime: Date;
  endTime: Date;
  merchant?: MerchantModel | null;
  invoiceDetails?: InvoiceDetailModel[] | null;
}

export class InvoiceDetailModel implements IInvoiceDetailModel {
  invoiceDetailId!: number;
  invoiceId!: number;
  buyOrderId!: number;
  invoice?: InvoiceModel | null;

  constructor(data?: IInvoiceDetailModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.invoiceDetailId =
        _data["invoiceDetailId"] !== undefined
          ? _data["invoiceDetailId"]
          : <any>null;
      this.invoiceId =
        _data["invoiceId"] !== undefined ? _data["invoiceId"] : <any>null;
      this.buyOrderId =
        _data["buyOrderId"] !== undefined ? _data["buyOrderId"] : <any>null;
      this.invoice = _data["invoice"]
        ? InvoiceModel.fromJS(_data["invoice"])
        : <any>null;
    }
  }

  static fromJS(data: any): InvoiceDetailModel {
    data = typeof data === "object" ? data : {};
    let result = new InvoiceDetailModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["invoiceDetailId"] =
      this.invoiceDetailId !== undefined ? this.invoiceDetailId : <any>null;
    data["invoiceId"] =
      this.invoiceId !== undefined ? this.invoiceId : <any>null;
    data["buyOrderId"] =
      this.buyOrderId !== undefined ? this.buyOrderId : <any>null;
    data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>null;
    return data;
  }
}

export interface IInvoiceDetailModel {
  invoiceDetailId: number;
  invoiceId: number;
  buyOrderId: number;
  invoice?: InvoiceModel | null;
}

export class MerchantCurrencyLimitModel implements IMerchantCurrencyLimitModel {
  merchantCurrencyLimitId!: number;
  merchantId!: number;
  amount!: number;
  currencyId!: number;
  createdTime!: Date;
  modifiedTime!: Date;
  merchant?: MerchantModel | null;
  currency?: CurrencyModel | null;

  constructor(data?: IMerchantCurrencyLimitModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.merchantCurrencyLimitId =
        _data["merchantCurrencyLimitId"] !== undefined
          ? _data["merchantCurrencyLimitId"]
          : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
      this.merchant = _data["merchant"]
        ? MerchantModel.fromJS(_data["merchant"])
        : <any>null;
      this.currency = _data["currency"]
        ? CurrencyModel.fromJS(_data["currency"])
        : <any>null;
    }
  }

  static fromJS(data: any): MerchantCurrencyLimitModel {
    data = typeof data === "object" ? data : {};
    let result = new MerchantCurrencyLimitModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["merchantCurrencyLimitId"] =
      this.merchantCurrencyLimitId !== undefined
        ? this.merchantCurrencyLimitId
        : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    return data;
  }
}

export interface IMerchantCurrencyLimitModel {
  merchantCurrencyLimitId: number;
  merchantId: number;
  amount: number;
  currencyId: number;
  createdTime: Date;
  modifiedTime: Date;
  merchant?: MerchantModel | null;
  currency?: CurrencyModel | null;
}

export class PaymentOrderStateLogModel implements IPaymentOrderStateLogModel {
  paymentOrderStateLogId!: number;
  paymentOrderId!: number;
  state!: PaymentOrderState;
  error?: string | null;
  createdTime!: Date;
  paymentOrder?: PaymentOrderModel | null;

  constructor(data?: IPaymentOrderStateLogModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentOrderStateLogId =
        _data["paymentOrderStateLogId"] !== undefined
          ? _data["paymentOrderStateLogId"]
          : <any>null;
      this.paymentOrderId =
        _data["paymentOrderId"] !== undefined
          ? _data["paymentOrderId"]
          : <any>null;
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.paymentOrder = _data["paymentOrder"]
        ? PaymentOrderModel.fromJS(_data["paymentOrder"])
        : <any>null;
    }
  }

  static fromJS(data: any): PaymentOrderStateLogModel {
    data = typeof data === "object" ? data : {};
    let result = new PaymentOrderStateLogModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["paymentOrderStateLogId"] =
      this.paymentOrderStateLogId !== undefined
        ? this.paymentOrderStateLogId
        : <any>null;
    data["paymentOrderId"] =
      this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["error"] = this.error !== undefined ? this.error : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["paymentOrder"] = this.paymentOrder
      ? this.paymentOrder.toJSON()
      : <any>null;
    return data;
  }
}

export interface IPaymentOrderStateLogModel {
  paymentOrderStateLogId: number;
  paymentOrderId: number;
  state: PaymentOrderState;
  error?: string | null;
  createdTime: Date;
  paymentOrder?: PaymentOrderModel | null;
}

export class UpdateSettingRequest implements IUpdateSettingRequest {
  startInvoiceDate?: PatchOfDateTime | null;
  invoiceDailyTime?: PatchOfDateTime | null;

  constructor(data?: IUpdateSettingRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.startInvoiceDate = _data["startInvoiceDate"]
        ? PatchOfDateTime.fromJS(_data["startInvoiceDate"])
        : <any>null;
      this.invoiceDailyTime = _data["invoiceDailyTime"]
        ? PatchOfDateTime.fromJS(_data["invoiceDailyTime"])
        : <any>null;
    }
  }

  static fromJS(data: any): UpdateSettingRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateSettingRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["startInvoiceDate"] = this.startInvoiceDate
      ? this.startInvoiceDate.toJSON()
      : <any>null;
    data["invoiceDailyTime"] = this.invoiceDailyTime
      ? this.invoiceDailyTime.toJSON()
      : <any>null;
    return data;
  }
}

export interface IUpdateSettingRequest {
  startInvoiceDate?: PatchOfDateTime | null;
  invoiceDailyTime?: PatchOfDateTime | null;
}

export class PatchOfDateTime implements IPatchOfDateTime {
  value!: Date;

  constructor(data?: IPatchOfDateTime) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"]
        ? new Date(_data["value"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PatchOfDateTime {
    data = typeof data === "object" ? data : {};
    let result = new PatchOfDateTime();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value ? this.value.toISOString() : <any>null;
    return data;
  }
}

export interface IPatchOfDateTime {
  value: Date;
}

export class CreatePaymentProfileRequest
  implements ICreatePaymentProfileRequest
{
  description!: string;
  name!: string;
  currencyId!: number;
  providerProfileId!: number;
  minAmount!: number;
  maxAmount!: number;
  imageUri1!: string;
  imageUri2!: string;

  constructor(data?: ICreatePaymentProfileRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.providerProfileId =
        _data["providerProfileId"] !== undefined
          ? _data["providerProfileId"]
          : <any>null;
      this.minAmount =
        _data["minAmount"] !== undefined ? _data["minAmount"] : <any>null;
      this.maxAmount =
        _data["maxAmount"] !== undefined ? _data["maxAmount"] : <any>null;
      this.imageUri1 =
        _data["imageUri1"] !== undefined ? _data["imageUri1"] : <any>null;
      this.imageUri2 =
        _data["imageUri2"] !== undefined ? _data["imageUri2"] : <any>null;
    }
  }

  static fromJS(data: any): CreatePaymentProfileRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreatePaymentProfileRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["providerProfileId"] =
      this.providerProfileId !== undefined ? this.providerProfileId : <any>null;
    data["minAmount"] =
      this.minAmount !== undefined ? this.minAmount : <any>null;
    data["maxAmount"] =
      this.maxAmount !== undefined ? this.maxAmount : <any>null;
    data["imageUri1"] =
      this.imageUri1 !== undefined ? this.imageUri1 : <any>null;
    data["imageUri2"] =
      this.imageUri2 !== undefined ? this.imageUri2 : <any>null;
    return data;
  }
}

export interface ICreatePaymentProfileRequest {
  description: string;
  name: string;
  currencyId: number;
  providerProfileId: number;
  minAmount: number;
  maxAmount: number;
  imageUri1: string;
  imageUri2: string;
}

export class UpdatePaymentProfileRequest
  implements IUpdatePaymentProfileRequest
{
  description?: PatchOfString | null;
  name?: PatchOfString | null;
  minAmount?: PatchOfNullableDecimal | null;
  maxAmount?: PatchOfNullableDecimal | null;
  imageUri1?: PatchOfUri | null;
  imageUri2?: PatchOfUri | null;

  constructor(data?: IUpdatePaymentProfileRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"]
        ? PatchOfString.fromJS(_data["description"])
        : <any>null;
      this.name = _data["name"]
        ? PatchOfString.fromJS(_data["name"])
        : <any>null;
      this.minAmount = _data["minAmount"]
        ? PatchOfNullableDecimal.fromJS(_data["minAmount"])
        : <any>null;
      this.maxAmount = _data["maxAmount"]
        ? PatchOfNullableDecimal.fromJS(_data["maxAmount"])
        : <any>null;
      this.imageUri1 = _data["imageUri1"]
        ? PatchOfUri.fromJS(_data["imageUri1"])
        : <any>null;
      this.imageUri2 = _data["imageUri2"]
        ? PatchOfUri.fromJS(_data["imageUri2"])
        : <any>null;
    }
  }

  static fromJS(data: any): UpdatePaymentProfileRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePaymentProfileRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["description"] = this.description
      ? this.description.toJSON()
      : <any>null;
    data["name"] = this.name ? this.name.toJSON() : <any>null;
    data["minAmount"] = this.minAmount ? this.minAmount.toJSON() : <any>null;
    data["maxAmount"] = this.maxAmount ? this.maxAmount.toJSON() : <any>null;
    data["imageUri1"] = this.imageUri1 ? this.imageUri1.toJSON() : <any>null;
    data["imageUri2"] = this.imageUri2 ? this.imageUri2.toJSON() : <any>null;
    return data;
  }
}

export interface IUpdatePaymentProfileRequest {
  description?: PatchOfString | null;
  name?: PatchOfString | null;
  minAmount?: PatchOfNullableDecimal | null;
  maxAmount?: PatchOfNullableDecimal | null;
  imageUri1?: PatchOfUri | null;
  imageUri2?: PatchOfUri | null;
}

export class PatchOfNullableDecimal implements IPatchOfNullableDecimal {
  value?: number | null;

  constructor(data?: IPatchOfNullableDecimal) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
    }
  }

  static fromJS(data: any): PatchOfNullableDecimal {
    data = typeof data === "object" ? data : {};
    let result = new PatchOfNullableDecimal();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value !== undefined ? this.value : <any>null;
    return data;
  }
}

export interface IPatchOfNullableDecimal {
  value?: number | null;
}

export class ApiKey implements IApiKey {
  accessToken!: Token;
  refreshToken?: Token | null;
  userId!: string;

  constructor(data?: IApiKey) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.accessToken = new Token();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"]
        ? Token.fromJS(_data["accessToken"])
        : new Token();
      this.refreshToken = _data["refreshToken"]
        ? Token.fromJS(_data["refreshToken"])
        : <any>null;
      this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
    }
  }

  static fromJS(data: any): ApiKey {
    data = typeof data === "object" ? data : {};
    let result = new ApiKey();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken
      ? this.accessToken.toJSON()
      : <any>null;
    data["refreshToken"] = this.refreshToken
      ? this.refreshToken.toJSON()
      : <any>null;
    data["userId"] = this.userId !== undefined ? this.userId : <any>null;
    return data;
  }
}

export interface IApiKey {
  accessToken: Token;
  refreshToken?: Token | null;
  userId: string;
}

export class Token implements IToken {
  value!: string;
  expirationTime!: Date;
  scheme!: string;
  issuedTime!: Date;

  constructor(data?: IToken) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
      this.expirationTime = _data["expirationTime"]
        ? new Date(_data["expirationTime"].toString())
        : <any>null;
      this.scheme = _data["scheme"] !== undefined ? _data["scheme"] : <any>null;
      this.issuedTime = _data["issuedTime"]
        ? new Date(_data["issuedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): Token {
    data = typeof data === "object" ? data : {};
    let result = new Token();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value !== undefined ? this.value : <any>null;
    data["expirationTime"] = this.expirationTime
      ? this.expirationTime.toISOString()
      : <any>null;
    data["scheme"] = this.scheme !== undefined ? this.scheme : <any>null;
    data["issuedTime"] = this.issuedTime
      ? this.issuedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IToken {
  value: string;
  expirationTime: Date;
  scheme: string;
  issuedTime: Date;
}

export class User implements IUser {
  userId!: string;
  email?: string | null;
  name?: string | null;
  firstName?: string | null;
  lastName?: string | null;
  pictureUrl?: string | null;
  phone?: string | null;
  createdTime!: Date;
  accessedTime?: Date | null;
  authorizationCode?: string | null;
  isDisabled!: boolean;
  isEmailVerified!: boolean;
  isPhoneVerified!: boolean;
  isBot!: boolean;
  description?: string | null;
  exData?: string | null;

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.firstName =
        _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
      this.lastName =
        _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
      this.pictureUrl =
        _data["pictureUrl"] !== undefined ? _data["pictureUrl"] : <any>null;
      this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.accessedTime = _data["accessedTime"]
        ? new Date(_data["accessedTime"].toString())
        : <any>null;
      this.authorizationCode =
        _data["authorizationCode"] !== undefined
          ? _data["authorizationCode"]
          : <any>null;
      this.isDisabled =
        _data["isDisabled"] !== undefined ? _data["isDisabled"] : <any>null;
      this.isEmailVerified =
        _data["isEmailVerified"] !== undefined
          ? _data["isEmailVerified"]
          : <any>null;
      this.isPhoneVerified =
        _data["isPhoneVerified"] !== undefined
          ? _data["isPhoneVerified"]
          : <any>null;
      this.isBot = _data["isBot"] !== undefined ? _data["isBot"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.exData = _data["exData"] !== undefined ? _data["exData"] : <any>null;
    }
  }

  static fromJS(data: any): User {
    data = typeof data === "object" ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId !== undefined ? this.userId : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["firstName"] =
      this.firstName !== undefined ? this.firstName : <any>null;
    data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
    data["pictureUrl"] =
      this.pictureUrl !== undefined ? this.pictureUrl : <any>null;
    data["phone"] = this.phone !== undefined ? this.phone : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["accessedTime"] = this.accessedTime
      ? this.accessedTime.toISOString()
      : <any>null;
    data["authorizationCode"] =
      this.authorizationCode !== undefined ? this.authorizationCode : <any>null;
    data["isDisabled"] =
      this.isDisabled !== undefined ? this.isDisabled : <any>null;
    data["isEmailVerified"] =
      this.isEmailVerified !== undefined ? this.isEmailVerified : <any>null;
    data["isPhoneVerified"] =
      this.isPhoneVerified !== undefined ? this.isPhoneVerified : <any>null;
    data["isBot"] = this.isBot !== undefined ? this.isBot : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["exData"] = this.exData !== undefined ? this.exData : <any>null;
    return data;
  }
}

export interface IUser {
  userId: string;
  email?: string | null;
  name?: string | null;
  firstName?: string | null;
  lastName?: string | null;
  pictureUrl?: string | null;
  phone?: string | null;
  createdTime: Date;
  accessedTime?: Date | null;
  authorizationCode?: string | null;
  isDisabled: boolean;
  isEmailVerified: boolean;
  isPhoneVerified: boolean;
  isBot: boolean;
  description?: string | null;
  exData?: string | null;
}

export class TeamUpdateBotParam implements ITeamUpdateBotParam {
  name?: PatchOfString | null;

  constructor(data?: ITeamUpdateBotParam) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"]
        ? PatchOfString.fromJS(_data["name"])
        : <any>null;
    }
  }

  static fromJS(data: any): TeamUpdateBotParam {
    data = typeof data === "object" ? data : {};
    let result = new TeamUpdateBotParam();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name ? this.name.toJSON() : <any>null;
    return data;
  }
}

export interface ITeamUpdateBotParam {
  name?: PatchOfString | null;
}

export class Role implements IRole {
  roleId!: string;
  roleName!: string;
  description?: string | null;

  constructor(data?: IRole) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
      this.roleName =
        _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
    }
  }

  static fromJS(data: any): Role {
    data = typeof data === "object" ? data : {};
    let result = new Role();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
    data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    return data;
  }
}

export interface IRole {
  roleId: string;
  roleName: string;
  description?: string | null;
}

export class ListResultOfUserRole implements IListResultOfUserRole {
  totalCount?: number | null;
  items!: UserRole[];

  constructor(data?: IListResultOfUserRole) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.items = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount =
        _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(UserRole.fromJS(item));
      } else {
        this.items = <any>null;
      }
    }
  }

  static fromJS(data: any): ListResultOfUserRole {
    data = typeof data === "object" ? data : {};
    let result = new ListResultOfUserRole();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] =
      this.totalCount !== undefined ? this.totalCount : <any>null;
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultOfUserRole {
  totalCount?: number | null;
  items: UserRole[];
}

export class UserRole2 implements IUserRole2 {
  resourceId!: string;
  userId!: string;
  role!: Role;

  constructor(data?: IUserRole2) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.role = new Role();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.resourceId =
        _data["resourceId"] !== undefined ? _data["resourceId"] : <any>null;
      this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
      this.role = _data["role"] ? Role.fromJS(_data["role"]) : new Role();
    }
  }

  static fromJS(data: any): UserRole2 {
    data = typeof data === "object" ? data : {};
    let result = new UserRole2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["resourceId"] =
      this.resourceId !== undefined ? this.resourceId : <any>null;
    data["userId"] = this.userId !== undefined ? this.userId : <any>null;
    data["role"] = this.role ? this.role.toJSON() : <any>null;
    return data;
  }
}

export interface IUserRole2 {
  resourceId: string;
  userId: string;
  role: Role;
}

export class UserRole extends UserRole2 implements IUserRole {
  user?: User | null;

  constructor(data?: IUserRole) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>null;
    }
  }

  static override fromJS(data: any): UserRole {
    data = typeof data === "object" ? data : {};
    let result = new UserRole();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["user"] = this.user ? this.user.toJSON() : <any>null;
    super.toJSON(data);
    return data;
  }
}

export interface IUserRole extends IUserRole2 {
  user?: User | null;
}

export class TeamAddBotParam implements ITeamAddBotParam {
  name!: string;

  constructor(data?: ITeamAddBotParam) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
    }
  }

  static fromJS(data: any): TeamAddBotParam {
    data = typeof data === "object" ? data : {};
    let result = new TeamAddBotParam();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name !== undefined ? this.name : <any>null;
    return data;
  }
}

export interface ITeamAddBotParam {
  name: string;
}

export class TeamAddEmailParam implements ITeamAddEmailParam {
  constructor(data?: ITeamAddEmailParam) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): TeamAddEmailParam {
    data = typeof data === "object" ? data : {};
    let result = new TeamAddEmailParam();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface ITeamAddEmailParam {}

export class SignInRequest implements ISignInRequest {
  idToken!: string;
  refreshTokenType!: RefreshTokenType;

  constructor(data?: ISignInRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.idToken =
        _data["idToken"] !== undefined ? _data["idToken"] : <any>null;
      this.refreshTokenType =
        _data["refreshTokenType"] !== undefined
          ? _data["refreshTokenType"]
          : <any>null;
    }
  }

  static fromJS(data: any): SignInRequest {
    data = typeof data === "object" ? data : {};
    let result = new SignInRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idToken"] = this.idToken !== undefined ? this.idToken : <any>null;
    data["refreshTokenType"] =
      this.refreshTokenType !== undefined ? this.refreshTokenType : <any>null;
    return data;
  }
}

export interface ISignInRequest {
  idToken: string;
  refreshTokenType: RefreshTokenType;
}

export enum RefreshTokenType {
  None = "None",
  Web = "Web",
  App = "App",
}

export class SignUpRequest implements ISignUpRequest {
  idToken!: string;
  refreshTokenType!: RefreshTokenType;

  constructor(data?: ISignUpRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.idToken =
        _data["idToken"] !== undefined ? _data["idToken"] : <any>null;
      this.refreshTokenType =
        _data["refreshTokenType"] !== undefined
          ? _data["refreshTokenType"]
          : <any>null;
    }
  }

  static fromJS(data: any): SignUpRequest {
    data = typeof data === "object" ? data : {};
    let result = new SignUpRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idToken"] = this.idToken !== undefined ? this.idToken : <any>null;
    data["refreshTokenType"] =
      this.refreshTokenType !== undefined ? this.refreshTokenType : <any>null;
    return data;
  }
}

export interface ISignUpRequest {
  idToken: string;
  refreshTokenType: RefreshTokenType;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
  refreshToken!: string;

  constructor(data?: IRefreshTokenRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken =
        _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
    }
  }

  static fromJS(data: any): RefreshTokenRequest {
    data = typeof data === "object" ? data : {};
    let result = new RefreshTokenRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["refreshToken"] =
      this.refreshToken !== undefined ? this.refreshToken : <any>null;
    return data;
  }
}

export interface IRefreshTokenRequest {
  refreshToken: string;
}

function formatDate(d: Date) {
  return (
    d.getFullYear() +
    "-" +
    (d.getMonth() < 9 ? "0" + (d.getMonth() + 1) : d.getMonth() + 1) +
    "-" +
    (d.getDate() < 10 ? "0" + d.getDate() : d.getDate())
  );
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}

export class ApiException extends Error {
  statusCode: number;
  response?: string;
  exceptionTypeName?: string;
  exceptionTypeFullName?: string;
  headers: any;
  data: any = {};

  constructor(
    message: string,
    statusCode: number,
    response?: any,
    headers?: any,
    innerException?: Error | null
  ) {
    if (!(response instanceof String)) response = JSON.stringify(response);
    super(ApiException.buildMessage(message, statusCode, response));
    Object.setPrototypeOf(this, ApiException.prototype);

    this.statusCode = statusCode;
    this.response = response;
    this.headers = headers;

    let serverException: ServerException | null =
      ServerException.tryParse(response);
    if (serverException) {
      Object.keys(serverException.Data).forEach((key) => {
        if (serverException) this.data[key] = serverException.Data[key];
      });
      this.exceptionTypeName = serverException.TypeName;
      this.exceptionTypeFullName = serverException.TypeFullName;
    }

    if (innerException) {
      this.stack = innerException.stack;
    }
  }

  private static buildMessage(
    message: string,
    statusCode: number,
    response?: string
  ): string {
    let serverException = ServerException.tryParse(response);
    if (serverException) return serverException.Message || "";

    return `${message}\n\nStatus: ${statusCode}\nResponse:\n${response?.substring(
      0,
      Math.min(512, response.length)
    )}`;
  }

  override toString(): string {
    return `HTTP Response:\n\n${this.response}\n\n${super.toString()}`;
  }
}

class ServerException {
  Data!: { [key: string]: string | null };
  TypeName?: string;
  TypeFullName?: string;
  Message?: string;

  public static tryParse(value: string | undefined): ServerException | null {
    if (!value) return null;

    try {
      let serverException: ServerException = JSON.parse(value);
      return serverException.TypeName ? serverException : null;
    } catch {
      return null;
    }
  }
}
